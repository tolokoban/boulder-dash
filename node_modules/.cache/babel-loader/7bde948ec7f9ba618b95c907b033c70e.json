{"ast":null,"code":"import _classCallCheck from \"/home/tolokoban/Code/github/boulder-dash/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/tolokoban/Code/github/boulder-dash/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * Here is the list of all parameters used if all the handlers.\n *\n * tap({ x: number, y: number, index: number })\n *\n */\nimport Moves from \"./gesture/moves\";\nimport BasicHandler from \"./gesture/basic-handler\";\nvar SYMBOL = Symbol(\"gesture\");\nvar ID = 0;\nvar STANDARD_EVENTS = [\"keydown\", \"keyup\"];\n\nvar Gesture =\n/*#__PURE__*/\nfunction () {\n  function Gesture(elem) {\n    _classCallCheck(this, Gesture);\n\n    this.elem = elem;\n    this.basicHandler = void 0;\n    this.handlers = void 0;\n    this.element = void 0;\n    this.pointers = void 0;\n    this.id = void 0;\n    elem[SYMBOL] = this;\n    this.id = ID++;\n    this.element = elem;\n    this.handlers = {};\n    this.basicHandler = new BasicHandler(elem, this.handleDown.bind(this), this.handleUp.bind(this), this.handleMove.bind(this));\n    this.pointers = new Array(3);\n  }\n\n  _createClass(Gesture, [{\n    key: \"on\",\n    value: function on(handlers) {\n      var _this = this;\n\n      this.handlers = Object.assign(this.handlers, handlers);\n      Object.keys(this.handlers).forEach(function (eventName) {\n        if (STANDARD_EVENTS.indexOf(eventName) === -1) return; // This is a non-pointer event. (i.e., keyboard, resize, ...)\n\n        _this.element.addEventListener(eventName, _this.handlers[eventName], false);\n      });\n    }\n    /**\n     * Check if a gesture has an handler attached.\n     *\n     * @param   {TGestureName[]}  gestureNames - Name of the gesture.\n     * @returns {boolean} true if the gesture is mapped to a handler.\n     */\n\n  }, {\n    key: \"hasHandlerFor\",\n    value: function hasHandlerFor() {\n      for (var _len = arguments.length, gestureNames = new Array(_len), _key = 0; _key < _len; _key++) {\n        gestureNames[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _gestureNames = gestureNames; _i < _gestureNames.length; _i++) {\n        var gestureName = _gestureNames[_i];\n        if (typeof this.handlers[gestureName] === 'function') return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getPointer\",\n    value: function getPointer(index) {\n      var pointers = this.pointers;\n\n      if (typeof pointers[index] === 'undefined') {\n        pointers[index] = {\n          isDown: false,\n          moves: new Moves(0, 0),\n          rect: {\n            left: 0,\n            top: 0,\n            width: 0,\n            height: 0\n          }\n        };\n      }\n\n      return pointers[index];\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(event) {\n      // We want not deal with more than 3 simultaneous touches.\n      if (event.index > 2) return;\n      var element = this.element;\n      var ptr = this.getPointer(event.index);\n      ptr.isDown = true;\n      ptr.rect = element.getBoundingClientRect();\n      var x = event.x - ptr.rect.left;\n      var y = event.y - ptr.rect.top;\n      ptr.moves.init(x, y);\n\n      if (this.hasHandlerFor(\"down\")) {\n        this.handlers.down(Object.assign(event, {\n          x: x,\n          y: y\n        }));\n      }\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(event) {\n      // We want not deal with more than 3 simultaneous touches.\n      if (event.index > 2) return;\n      var ptr = this.getPointer(event.index);\n      ptr.isDown = false;\n      var x = event.x - ptr.rect.left;\n      var y = event.y - ptr.rect.top;\n      ptr.moves.add(x, y);\n\n      if (this.hasHandlerFor(\"up\")) {\n        this.handlers.up(Object.assign(event, {\n          x: x,\n          y: y\n        }));\n      }\n\n      this.recognizeTap(event, ptr);\n      this.recognizeSwipe(event, ptr);\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(event) {\n      // We want not deal with more than 3 simultaneous touches.\n      if (event.index > 2) return;\n      var ptr = this.getPointer(event.index);\n      var x = event.x - ptr.rect.left;\n      var y = event.y - ptr.rect.top;\n      ptr.moves.add(x, y);\n      this.recognizePan(event, ptr);\n    }\n  }, {\n    key: \"recognizeTap\",\n    value: function recognizeTap(evt, ptr) {\n      // A tap is recognized only if there is less than 400ms\n      // between down and up, and if the pointer has not moves more\n      // than 16px.\n      if (!this.hasHandlerFor(\"tap\") || ptr.moves.elapsedTime > 400) return;\n      var moves = ptr.moves;\n      var dx = Math.abs(moves.x - moves.startX);\n      if (dx > 16) return;\n      var dy = Math.abs(moves.y - moves.startY);\n      if (dy > 16) return;\n      evt.clear();\n      this.handlers.tap(Object.assign(evt, {\n        x: moves.x,\n        y: moves.y\n      }));\n    }\n  }, {\n    key: \"recognizePan\",\n    value: function recognizePan(evt, ptr) {\n      if (!ptr.isDown) return;\n      this.recognizePanDown(evt, ptr);\n      this.recognizePanUp(evt, ptr);\n\n      if (this.hasHandlerFor(\"pan\")) {\n        var _ptr$moves = ptr.moves,\n            x = _ptr$moves.x,\n            y = _ptr$moves.y,\n            startX = _ptr$moves.startX,\n            startY = _ptr$moves.startY;\n        this.handlers.pan(Object.assign(evt, {\n          x: x,\n          y: y,\n          startX: startX,\n          startY: startY\n        }));\n      }\n    }\n  }, {\n    key: \"recognizePanDown\",\n    value: function recognizePanDown(evt, ptr) {\n      if (!this.hasHandlerFor(\"pandown\", \"panvertical\")) return; // Check that we are panning down.\n\n      var moves = ptr.moves;\n      var sx = Math.abs(moves.speedX);\n      var sy = moves.speedY;\n      if (sy < sx) return; // Check that the final point is beneath the initial one.\n\n      var dx = Math.abs(moves.x - moves.startX);\n      var dy = moves.y - moves.startY;\n      if (dy < dx) return;\n\n      if (this.hasHandlerFor(\"pandown\")) {\n        this.handlers.pandown(Object.assign(evt, {\n          x: moves.x,\n          y: moves.y\n        }));\n      }\n\n      if (this.hasHandlerFor(\"panvertical\")) {\n        this.handlers.panvertical(Object.assign(evt, {\n          x: moves.x,\n          y: moves.y\n        }));\n      }\n    }\n  }, {\n    key: \"recognizePanUp\",\n    value: function recognizePanUp(evt, ptr) {\n      if (!this.hasHandlerFor(\"panup\", \"panvertical\")) return; // Check that we are panning up.\n\n      var moves = ptr.moves;\n      var sx = Math.abs(moves.speedX);\n      var sy = -moves.speedY;\n      if (sy < sx) return; // Check that the final point is beneath the initial one.\n\n      var dx = Math.abs(moves.x - moves.startX);\n      var dy = moves.startY - moves.y;\n      if (dy < dx) return;\n\n      if (this.hasHandlerFor(\"panup\")) {\n        this.handlers.panup(Object.assign(evt, {\n          x: moves.x,\n          y: moves.y\n        }));\n      }\n\n      if (this.hasHandlerFor(\"panvertical\")) {\n        this.handlers.panvertical(Object.assign(evt, {\n          x: moves.x,\n          y: moves.y\n        }));\n      }\n    }\n  }, {\n    key: \"recognizeSwipe\",\n    value: function recognizeSwipe(evt, ptr) {\n      this.recognizeSwipeDown(evt, ptr);\n      this.recognizeSwipeUp(evt, ptr);\n      this.recognizeSwipeLeft(evt, ptr);\n\n      if (this.hasHandlerFor(\"swipe\")) {\n        var _ptr$moves2 = ptr.moves,\n            x = _ptr$moves2.x,\n            y = _ptr$moves2.y,\n            startX = _ptr$moves2.startX,\n            startY = _ptr$moves2.startY;\n        this.handlers.swipe(Object.assign(evt, {\n          x: x,\n          y: y,\n          startX: startX,\n          startY: startY\n        }));\n      }\n    }\n  }, {\n    key: \"recognizeSwipeDown\",\n    value: function recognizeSwipeDown(evt, ptr) {\n      if (!this.hasHandlerFor(\"swipedown\", \"swipevertical\")) return; // Check that we are panning down.\n\n      var moves = ptr.moves;\n      var sx = Math.abs(moves.speedX);\n      var sy = moves.speedY;\n      if (sy < sx) return; // Check that the final point is beneath the initial one.\n\n      var dx = Math.abs(moves.x - moves.startX);\n      var dy = moves.y - moves.startY;\n      if (dy < dx) return; // Minimal speed for swipe: 100 pixels/second.\n\n      var speed = dy / moves.elapsedTime;\n      if (speed < 0.1) return;\n\n      if (this.hasHandlerFor(\"swipedown\")) {\n        this.handlers.swipedown(Object.assign(evt, {\n          x: moves.x,\n          y: moves.y\n        }));\n      }\n\n      if (this.hasHandlerFor(\"swipevertical\")) {\n        this.handlers.swipevertical(Object.assign(evt, {\n          x: moves.x,\n          y: moves.y\n        }));\n      }\n    }\n  }, {\n    key: \"recognizeSwipeUp\",\n    value: function recognizeSwipeUp(evt, ptr) {\n      if (!this.hasHandlerFor(\"swipeup\", \"swipevertical\")) return; // Check that we are panning up.\n\n      var moves = ptr.moves;\n      var sx = Math.abs(moves.speedX);\n      var sy = moves.speedY;\n      if (sy < sx) return; // Check that the final point is beneath the initial one.\n\n      var dx = Math.abs(moves.x - moves.startX);\n      var dy = moves.y - moves.startY;\n      if (dy < dx) return; // Minimal speed for swipe: 100 pixels/second.\n\n      var speed = dy / moves.elapsedTime;\n      if (speed < 0.1) return;\n\n      if (this.hasHandlerFor(\"swipeup\")) {\n        this.handlers.swipeup(Object.assign(evt, {\n          x: moves.x,\n          y: moves.y\n        }));\n      }\n\n      if (this.hasHandlerFor(\"swipevertical\")) {\n        this.handlers.swipevertical(Object.assign(evt, {\n          x: moves.x,\n          y: moves.y\n        }));\n      }\n    }\n  }, {\n    key: \"recognizeSwipeLeft\",\n    value: function recognizeSwipeLeft(evt, ptr) {\n      if (!this.hasHandlerFor(\"swipeleft\", \"swipehorizontal\")) return; // Check that we are panning left.\n\n      var moves = ptr.moves;\n      var sx = -moves.speedX;\n      var sy = Math.abs(moves.speedY);\n      if (sx < sy) return; // Check that the final point is beneath the initial one.\n\n      var dx = moves.startX - moves.x;\n      var dy = Math.abs(moves.y - moves.startY);\n      if (dx < dy) return; // Minimal speed for swipe: 100 pixels/second.\n\n      var speed = dx / moves.elapsedTime;\n      if (speed < 0.1) return;\n\n      if (this.hasHandlerFor(\"swipeleft\")) {\n        this.handlers.swipeleft(Object.assign(evt, {\n          x: moves.x,\n          y: moves.y\n        }));\n      }\n\n      if (this.hasHandlerFor(\"swipehorizontal\")) {\n        this.handlers.swipehorizontal(Object.assign(evt, {\n          x: moves.x,\n          y: moves.y\n        }));\n      }\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return this.id;\n    }\n  }]);\n\n  return Gesture;\n}();\n\nexport default function (elem) {\n  if (!elem[SYMBOL]) {\n    elem[SYMBOL] = new Gesture(elem);\n  }\n\n  return elem[SYMBOL];\n}","map":{"version":3,"sources":["/home/tolokoban/Code/github/boulder-dash/src/tfw/gesture.ts"],"names":["Moves","BasicHandler","SYMBOL","Symbol","ID","STANDARD_EVENTS","Gesture","elem","basicHandler","handlers","element","pointers","id","handleDown","bind","handleUp","handleMove","Array","Object","assign","keys","forEach","eventName","indexOf","addEventListener","gestureNames","gestureName","index","isDown","moves","rect","left","top","width","height","event","ptr","getPointer","getBoundingClientRect","x","y","init","hasHandlerFor","down","add","up","recognizeTap","recognizeSwipe","recognizePan","evt","elapsedTime","dx","Math","abs","startX","dy","startY","clear","tap","recognizePanDown","recognizePanUp","pan","sx","speedX","sy","speedY","pandown","panvertical","panup","recognizeSwipeDown","recognizeSwipeUp","recognizeSwipeLeft","swipe","speed","swipedown","swipevertical","swipeup","swipeleft","swipehorizontal"],"mappings":"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","sourcesContent":["/**\n * Here is the list of all parameters used if all the handlers.\n *\n * tap({ x: number, y: number, index: number })\n *\n */\n\nimport Moves from \"./gesture/moves\"\nimport BasicHandler from \"./gesture/basic-handler\"\nimport { IBasicEvent } from \"./gesture/basic-handler.types\"\n\nconst SYMBOL = Symbol(\"gesture\");\n\nlet ID = 0;\n\ntype TGestureName = \"tap\" | \"down\" | \"up\"\n    | \"pan\" | \"pandown\" | \"panup\" | \"panvertical\"\n    | \"swipe\" | \"swipedown\" | \"swipeup\" | \"swipevertical\"\n    | \"swipeleft\";\ntype TEventName = \"keydown\" | \"keyup\";\ntype THandlers = {\n    [key: TGestureName | TEventName]: (event: IEvent) => void;\n};\n\ninterface IEvent {\n    preventDefault: () => void;\n    stopPropagation: () => void;\n    target: HTMLElement;\n    x?: number;\n    y?: number;\n}\n\ninterface IInternalEvent {\n    x?: number;\n    y?: number;\n    event: PointerEvent;\n}\n\ninterface IPointer {\n    isDown: boolean;\n    moves: Moves;\n    rect: {\n        left: number;\n        top: number;\n        width: number;\n        height: number;\n    };\n    type: string | null;\n    time: number;\n    id: number;\n}\n\nconst STANDARD_EVENTS = [\"keydown\", \"keyup\"];\n\nclass Gesture {\n    private readonly basicHandler: BasicHandler;\n    private handlers: THandlers;\n    private element: HTMLElement;\n    private readonly pointers: IPointer[];\n    private readonly id: number;\n\n    constructor(private elem: HTMLElement) {\n        elem[SYMBOL] = this;\n        this.id = ID++;\n        this.element = elem;\n        this.handlers = {};\n        this.basicHandler = new BasicHandler(\n            elem,\n            this.handleDown.bind(this),\n            this.handleUp.bind(this),\n            this.handleMove.bind(this)\n        )\n        this.pointers = new Array(3);\n    }\n\n    get identifier() { return this.id; }\n\n    on(handlers: THandlers) {\n        this.handlers = Object.assign(this.handlers, handlers);\n        Object.keys(this.handlers).forEach(eventName => {\n            if (STANDARD_EVENTS.indexOf(eventName) === -1) return;\n            // This is a non-pointer event. (i.e., keyboard, resize, ...)\n            this.element.addEventListener(eventName, this.handlers[eventName], false);\n        });\n    }\n\n    /**\n     * Check if a gesture has an handler attached.\n     *\n     * @param   {TGestureName[]}  gestureNames - Name of the gesture.\n     * @returns {boolean} true if the gesture is mapped to a handler.\n     */\n    hasHandlerFor(...gestureNames: TGestureName[]): boolean {\n        for (const gestureName of gestureNames) {\n            if (typeof this.handlers[gestureName] === 'function') return true;\n        }\n        return false;\n    }\n\n    private getPointer(index: number) {\n        const pointers = this.pointers;\n        if (typeof pointers[index] === 'undefined') {\n            pointers[index] = {\n                isDown: false,\n                moves: new Moves(0, 0),\n                rect: { left: 0, top: 0, width: 0, height: 0 }\n            }\n        }\n        return pointers[index];\n    }\n\n    private handleDown(event: IBasicEvent) {\n        // We want not deal with more than 3 simultaneous touches.\n        if (event.index > 2) return;\n\n        const { element } = this;\n        const ptr = this.getPointer(event.index);\n        ptr.isDown = true;\n        ptr.rect = element.getBoundingClientRect();\n        const x = event.x - ptr.rect.left;\n        const y = event.y - ptr.rect.top;\n        ptr.moves.init(x, y);\n\n        if (this.hasHandlerFor(\"down\")) {\n            this.handlers.down(Object.assign(event, { x, y }));\n        }\n    }\n\n    private handleUp(event: IBasicEvent) {\n        // We want not deal with more than 3 simultaneous touches.\n        if (event.index > 2) return;\n\n        const ptr = this.getPointer(event.index);\n        ptr.isDown = false;\n        const x = event.x - ptr.rect.left;\n        const y = event.y - ptr.rect.top;\n        ptr.moves.add(x, y);\n\n        if (this.hasHandlerFor(\"up\")) {\n            this.handlers.up(Object.assign(event, { x, y }));\n        }\n        this.recognizeTap(event, ptr);\n        this.recognizeSwipe(event, ptr);\n    }\n\n    private handleMove(event: IBasicEvent) {\n        // We want not deal with more than 3 simultaneous touches.\n        if (event.index > 2) return;\n\n        const ptr = this.getPointer(event.index);\n        const x = event.x - ptr.rect.left;\n        const y = event.y - ptr.rect.top;\n        ptr.moves.add(x, y);\n        this.recognizePan(event, ptr);\n    }\n\n    private recognizeTap(evt: IBasicEvent, ptr: IPointer) {\n        // A tap is recognized only if there is less than 400ms\n        // between down and up, and if the pointer has not moves more\n        // than 16px.\n        if (!this.hasHandlerFor(\"tap\") || ptr.moves.elapsedTime > 400) return;\n        const moves = ptr.moves;\n        const dx = Math.abs(moves.x - moves.startX);\n        if (dx > 16) return;\n        const dy = Math.abs(moves.y - moves.startY);\n        if (dy > 16) return;\n\n        evt.clear();\n        this.handlers.tap(Object.assign(evt, { x: moves.x, y: moves.y }));\n    }\n\n    private recognizePan(evt: IBasicEvent, ptr: IPointer) {\n        if (!ptr.isDown) return;\n        this.recognizePanDown(evt, ptr);\n        this.recognizePanUp(evt, ptr);\n        if (this.hasHandlerFor(\"pan\")) {\n            const { x, y, startX, startY } = ptr.moves;\n            this.handlers.pan(Object.assign(evt, { x, y, startX, startY }));\n        }\n    }\n\n    private recognizePanDown(evt: IBasicEvent, ptr: IPointer) {\n        if (!this.hasHandlerFor(\"pandown\", \"panvertical\")) return;\n\n        // Check that we are panning down.\n        const moves = ptr.moves;\n        const sx = Math.abs(moves.speedX);\n        const sy = moves.speedY;\n        if (sy < sx) return;\n        // Check that the final point is beneath the initial one.\n        const dx = Math.abs(moves.x - moves.startX);\n        const dy = moves.y - moves.startY;\n        if (dy < dx) return;\n\n        if (this.hasHandlerFor(\"pandown\")) {\n            this.handlers.pandown(Object.assign(evt, { x: moves.x, y: moves.y }));\n        }\n        if (this.hasHandlerFor(\"panvertical\")) {\n            this.handlers.panvertical(Object.assign(evt, { x: moves.x, y: moves.y }));\n        }\n    }\n\n    private recognizePanUp(evt: IBasicEvent, ptr: IPointer) {\n        if (!this.hasHandlerFor(\"panup\", \"panvertical\")) return;\n\n        // Check that we are panning up.\n        const moves = ptr.moves;\n        const sx = Math.abs(moves.speedX);\n        const sy = -moves.speedY;\n        if (sy < sx) return;\n        // Check that the final point is beneath the initial one.\n        const dx = Math.abs(moves.x - moves.startX);\n        const dy = moves.startY - moves.y;\n        if (dy < dx) return;\n\n        if (this.hasHandlerFor(\"panup\")) {\n            this.handlers.panup(Object.assign(evt, { x: moves.x, y: moves.y }));\n        }\n        if (this.hasHandlerFor(\"panvertical\")) {\n            this.handlers.panvertical(Object.assign(evt, { x: moves.x, y: moves.y }));\n        }\n    }\n\n    private recognizeSwipe(evt: IBasicEvent, ptr: IPointer) {\n        this.recognizeSwipeDown(evt, ptr);\n        this.recognizeSwipeUp(evt, ptr);\n        this.recognizeSwipeLeft(evt, ptr);\n        if (this.hasHandlerFor(\"swipe\")) {\n            const { x, y, startX, startY } = ptr.moves;\n            this.handlers.swipe(Object.assign(evt, { x, y, startX, startY }));\n        }\n    }\n\n    private recognizeSwipeDown(evt: IBasicEvent, ptr: IPointer) {\n        if (!this.hasHandlerFor(\"swipedown\", \"swipevertical\")) return;\n\n        // Check that we are panning down.\n        const moves = ptr.moves;\n        const sx = Math.abs(moves.speedX);\n        const sy = moves.speedY;\n        if (sy < sx) return;\n        // Check that the final point is beneath the initial one.\n        const dx = Math.abs(moves.x - moves.startX);\n        const dy = moves.y - moves.startY;\n        if (dy < dx) return;\n        // Minimal speed for swipe: 100 pixels/second.\n        const speed = dy / moves.elapsedTime;\n        if (speed < 0.1) return;\n        if (this.hasHandlerFor(\"swipedown\")) {\n            this.handlers.swipedown(Object.assign(evt, { x: moves.x, y: moves.y }));\n        }\n        if (this.hasHandlerFor(\"swipevertical\")) {\n            this.handlers.swipevertical(Object.assign(evt, { x: moves.x, y: moves.y }));\n        }\n    }\n\n    private recognizeSwipeUp(evt: IBasicEvent, ptr: IPointer) {\n        if (!this.hasHandlerFor(\"swipeup\", \"swipevertical\")) return;\n\n        // Check that we are panning up.\n        const moves = ptr.moves;\n        const sx = Math.abs(moves.speedX);\n        const sy = moves.speedY;\n        if (sy < sx) return;\n        // Check that the final point is beneath the initial one.\n        const dx = Math.abs(moves.x - moves.startX);\n        const dy = moves.y - moves.startY;\n        if (dy < dx) return;\n        // Minimal speed for swipe: 100 pixels/second.\n        const speed = dy / moves.elapsedTime;\n        if (speed < 0.1) return;\n        if (this.hasHandlerFor(\"swipeup\")) {\n            this.handlers.swipeup(Object.assign(evt, { x: moves.x, y: moves.y }));\n        }\n        if (this.hasHandlerFor(\"swipevertical\")) {\n            this.handlers.swipevertical(Object.assign(evt, { x: moves.x, y: moves.y }));\n        }\n    }\n\n    private recognizeSwipeLeft(evt: IBasicEvent, ptr: IPointer) {\n        if (!this.hasHandlerFor(\"swipeleft\", \"swipehorizontal\")) return;\n\n        // Check that we are panning left.\n        const moves = ptr.moves;\n        const sx = -moves.speedX;\n        const sy = Math.abs(moves.speedY);\n        if (sx < sy) return;\n        // Check that the final point is beneath the initial one.\n        const dx = moves.startX - moves.x;\n        const dy = Math.abs(moves.y - moves.startY);\n        if (dx < dy) return;\n        // Minimal speed for swipe: 100 pixels/second.\n        const speed = dx / moves.elapsedTime;\n        if (speed < 0.1) return;\n        if (this.hasHandlerFor(\"swipeleft\")) {\n            this.handlers.swipeleft(Object.assign(evt, { x: moves.x, y: moves.y }));\n        }\n        if (this.hasHandlerFor(\"swipehorizontal\")) {\n            this.handlers.swipehorizontal(Object.assign(evt, { x: moves.x, y: moves.y }));\n        }\n    }\n}\n\nexport default function(elem: HTMLElement): Gesture {\n    if (!elem[SYMBOL]) {\n        elem[SYMBOL] = new Gesture(elem);\n    }\n    return elem[SYMBOL];\n}\n"]},"metadata":{},"sourceType":"module"}
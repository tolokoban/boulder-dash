{"ast":null,"code":"export default {\n  createEnv: createEnv,\n  apply: apply,\n  process: process\n};\n\nfunction isRockOrDiam(level, col, row) {\n  var cell = level.getType(col, row);\n  return cell === Level.ROCK || cell === Level.DIAM;\n}\n\nfunction isRockOrDiamOrWall(level, col, row) {\n  var cell = level.getType(col, row);\n  return cell === Level.ROCK || cell === Level.DIAM || cell === Level.WALL;\n}\n\nfunction prepareMove(col, row, vx, vy, env) {\n  if (vx === 0 && vy === 0) return;\n  var level = env.level;\n  var src = level.getType(col, row);\n  var dst = level.getType(col + vx, row + vy);\n  if (dst === Level.HERO) env.killHero();else {\n    level.setMove(col, row, vx, vy);\n    level.setType(col + vx, row + vy, -src);\n  }\n}\n\n;\n\nfunction processFallingRockOrDiam(level, col, row, env, below) {\n  // La pierre est déjà en train de tomber.\n  // On regarde s'il y a autre chose que du vide dessous. Si c'est\n  // le cas, la chute est stoppée,  mais il peut aussi y avoir des\n  // conséquences sur l'élément qui se trouvait en dessous.\n  if (below !== Level.VOID) {\n    // On arrête la chute dans tous les cas.\n    level.setVY(col, row, 0);\n\n    if (below == Level.ROCK || below == Level.WALL || below == Level.DUST) {\n      // Le rocher  (ou diamant)  a été  stoppé :  on joue  un son\n      // adéquat.\n      env.playBoom();\n    } else if (below == Level.HERO) {\n      // On tombe sur le héro : ça le tue.\n      env.killHero();\n    } else if (below == Level.MONS) {\n      // On écrase un monstre.\n      level.setType(col, row, Level.VOID);\n      env.explode(col, row + 1, true);\n    } else if (below == Level.DIAM) {\n      // Si c'est une pierre qui tombe sur un diamant, il explose.\n      if (level.getType(col, row) === Level.ROCK) {\n        level.setType(col, row, Level.VOID);\n        env.explode(col, row + 1);\n      }\n    }\n  } else {\n    level.setType(col, row + 1, Level.BOOM);\n  }\n}\n\nfunction processSteadyRockOrDiam(level, col, row, env, below) {\n  // La pierre est au repos.\n  if (below === Level.VOID) {\n    level.setMove(col, row, 0, 1);\n    level.setType(col, row + 1, Level.BOOM);\n  } else if (isRockOrDiamOrWall(level, col, row + 1)) {\n    if (!isRockOrDiam(level, col, row - 1)) {\n      // Si un rocher est posé sur un autre  et qu'il n'est pas sous un rocher/diamant, alors il\n      // peut basculer à droite ou à gauche si l'espace est libre.\n      if (level.getType(col + 1, row) == Level.VOID && level.getType(col + 1, row + 1) == Level.VOID && !isRockOrDiam(level, col + 1, row - 1)) {\n        // On tombe sur la droite.\n        level.setMove(col, row, +1, 0);\n      } else if (level.getType(col - 1, row) == Level.VOID && level.getType(col - 1, row + 1) == Level.VOID && !isRockOrDiam(level, col - 1, row - 1)) {\n        // On tombe sur la gauche seulement s'il n'y a pas déjà un\n        // rocher qui tombe sur la droite juste en face.\n        if (col < 2 || !isRockOrDiam(level, col - 2, row) || level.getVX(col - 2, row) < 1) {\n          level.setMove(col, row, -1, 0);\n        }\n      }\n    }\n  }\n}\n\nfunction processRockOrDiam(level, col, row, env) {\n  level.setVX(col, row, 0); // On arrête tout déplacement horizontal.\n\n  var below = level.getType(col, row + 1);\n  var falling = level.getVY(col, row) != 0;\n\n  if (falling) {\n    processFallingRockOrDiam(level, col, row, env, below);\n  } else {\n    processSteadyRockOrDiam(level, col, row, env, below);\n  }\n}\n\nfunction processExplosion1(env, level, col, row) {\n  // Une explosion a une durée de vie de 2 cycles.\n  if (level.getIndex(col, row) > 0) {\n    // Encore un cycle...\n    level.setIndex(col, row, level.getIndex(col, row) - 1);\n  } else {\n    // C'est terminé pour l'explosion.\n    level.setType(col, row, Level.VOID);\n  }\n}\n\nfunction processExplosion2(env, level, col, row) {\n  // Une explosion a une durée de vie de 2 cycles.\n  if (level.getIndex(col, row) > 0) {\n    // Encore un cycle...\n    level.setIndex(col, row, level.getIndex(col, row) - 1);\n  } else {\n    // C'est terminé pour l'explosion.\n    level.setType(col, row, Level.DIAM);\n    level.setIndex(col, row, Math.floor(Math.random() * 16));\n  }\n} // Directions du monstre en fonction de attIndex.\n// Il essaie  d'aller dans sa  direction et si c'est  impossible, il\n// essaie sur sa droite et ainsi de suite...\n\n\nvar dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];\n\nfunction processMonster(env, level, col, row) {\n  var dir = level.getIndex(col, row);\n  var d, k;\n  var vx, vy, v;\n  var target;\n\n  for (k = 5; k > 1; k--) {\n    d = (dir + k) % 4;\n    v = dirs[d];\n    vx = v[0];\n    vy = v[1];\n    target = level.getType(col + vx, row + vy);\n\n    switch (target) {\n      case Level.VOID:\n        prepareMove(col, row, vx, vy, env);\n        level.setIndex(col, row, d);\n        return;\n\n      case Level.HERO:\n        env.killHero();\n        return;\n\n      case Level.ROCK:\n      case Level.DIAM:\n        if (d == 0) {\n          // Si on  monte vers  une pierre,  c'est qu'elle  nous fonce\n          // dessus.\n          env.explode(col, row, true);\n          return;\n        }\n\n        break;\n\n      case Level.BOOM:\n        env.explode(col, row, true);\n        return;\n    }\n  }\n\n  level.setMove(col, row, 0, 0);\n}\n\nfunction processHero(env, level, col, row, heroMoves, action) {\n  // Si le héro est mort, on ne fait rien du tout.\n  if (!env.isHeroAlive) {\n    env.camX = 0;\n    env.camY = 0;\n    return;\n  }\n\n  var move = true;\n  var vx = 0;\n  var vy = 0;\n\n  switch (action) {\n    case GameInputs.UP:\n      vx = 0;\n      vy = -1;\n      break;\n\n    case GameInputs.RIGHT:\n      vx = 1;\n      vy = 0;\n      level.setIndex(col, row, 0);\n      break;\n\n    case GameInputs.DOWN:\n      vx = 0;\n      vy = 1;\n      break;\n\n    case GameInputs.LEFT:\n      vx = -1;\n      vy = 0;\n      level.setIndex(col, row, 1);\n      break;\n\n    case GameInputs.SUICIDE:\n      env.killHero();\n      move = false;\n      break;\n\n    default:\n      move = false;\n      break;\n  }\n\n  if (move) {\n    var nextX = col + vx;\n    var nextY = row + vy;\n    var cell = level.getType(nextX, nextY);\n\n    if (cell === Level.WALL || cell === Level.HERO) {\n      // Les murs arrêtent le déplacement. Les clones aussi.\n      env.camX = col;\n      env.camY = row;\n      env.camVX = 0;\n      env.camVY = 0;\n      return;\n    }\n\n    if (cell === Level.ROCK) {\n      // Les rochers aussi, mais ils  peuvent être poussés s'ils ont\n      // un espace vide derrière eux.\n      if (vx === +1 && level.getType(nextX + 1, nextY) === Level.VOID) {\n        level.setVX(nextX, nextY, +1);\n        level.flag(nextX, nextY);\n      } else if (vx === -1 && level.getType(nextX - 1, nextY) === Level.VOID) {\n        level.setVX(nextX, nextY, -1);\n      } // Le héro s'arrête net parce que le rocher est lourd.\n\n\n      level.setMove(col, row, 0, 0);\n      vx = vy = 0;\n    } else {\n      heroMoves.push([col, row]);\n      level.flag(nextX, nextY);\n      level.setMove(col, row, vx, vy);\n    }\n  }\n\n  env.camX = col;\n  env.camY = row;\n  env.camVX = vx;\n  env.camVY = vy;\n} // Déterminer les déplacements futurs.\n\n\nfunction process(env, action) {\n  // Chaque héro peut manger de la terres (feuilles), mais il faut\n  // la retirer dans  un deuxième temps pour éviter  des effets de\n  // bord sur la chute de pierres vers la gauche.\n  // En effet, si on a une pile de pierre à deux cases à droite du\n  // héro et  que ce dernier  creuse juste à droite,  la prochaine\n  // case analysée sera celle de la pierre et on verra qu'il n'y a\n  // plus rien  à gauche, alors  qu'en réalité, c'est le  héro qui\n  // est censé prendre cette place.\n  // Le résultat  sera que  la pierre  et le  héro auront  la même\n  // cellule comme destination.\n  // `heroMoves` contient les coordonnées du héro.\n  var heroMoves = [];\n  var level = env.level;\n  var row, col, cell;\n\n  for (row = 0; row < level.rows; row++) {\n    for (col = 0; col < level.cols; col++) {\n      if (level.hasFlag(col, row)) {\n        level.unflag(col, row);\n        continue;\n      }\n\n      cell = level.getType(col, row);\n\n      if (cell === Level.ROCK || cell === Level.DIAM) {\n        processRockOrDiam(level, col, row, env);\n      } else if (level.getType(col, row) === Level.HERO) {\n        processHero(env, level, col, row, heroMoves, action);\n      } else if (cell === Level.MONS) {\n        processMonster(env, level, col, row);\n      } else if (cell === Level.EXP1) {\n        processExplosion1(env, level, col, row);\n      } else if (cell === Level.EXP2) {\n        processExplosion2(env, level, col, row);\n      }\n    }\n  }\n\n  heroMoves.forEach(function (move) {\n    var col = move[0];\n    var row = move[1];\n    var vx = level.getVX(col, row);\n    var vy = level.getVY(col, row);\n    col += vx;\n    row += vy;\n    var cell = level.getType(col, row);\n\n    if (cell === Level.DUST) {\n      level.setType(col, row, Level.VOID);\n    } else if (cell === Level.DIAM) {\n      env.eatDiam();\n      level.setType(col, row, Level.VOID);\n    } else if (cell === Level.EXIT) env.nextLevel();else if (cell !== Level.VOID) env.killHero();\n  });\n} // Appliquer les déplacements de chaque cellule.\n\n\nfunction apply(env) {\n  var level = env.level;\n  var row, col;\n  var isHeroAlive = false;\n\n  for (row = 0; row < level.rows; row++) {\n    for (col = 0; col < level.cols; col++) {\n      if (level.getType(col, row) === Level.HERO) isHeroAlive = true;\n\n      if (level.hasFlag(col, row)) {\n        // Cellule avec un flag : il ne faut pas la traiter.\n        level.unflag(col, row);\n        continue;\n      }\n\n      var vx = level.getVX(col, row);\n      var vy = level.getVY(col, row);\n\n      if (vx != 0 || vy != 0) {\n        level.move(col, row, col + vx, row + vy);\n\n        if (vx > 0 || vy > 0) {\n          // On  flag une  cellule  si  elle est  à  droite ou  en\n          // dessous de  la cellule courante.  Cela  évitera de la\n          // prendre  en compte  une  deuxième fois  dans le  même\n          // cycle.\n          level.flag(col + vx, row + vy);\n        }\n      }\n    }\n  }\n\n  if (!isHeroAlive) env.killHero();\n}\n\nfunction createEnv(gl, assets) {\n  return {\n    gl: gl,\n    assets: assets,\n    x: 0,\n    y: 0,\n    z: 0,\n    w: 1,\n    cellTime: 180,\n    // Temps en ms pour traverser une cellule.\n    nextSynchro: -1,\n    levelNumber: 0,\n    score: 0,\n    bonus: 0,\n    divDiam: document.getElementById(\"diam\"),\n    divScore: document.getElementById(\"score\"),\n    //#(eatDiam)\n    eatenDiams: 0,\n    eatDiam: function eatDiam() {\n      // Les assets finissant par 'ogg', 'mp3' ou 'wav'\n      // sont transpformés en tag AUDIO.\n      assets.diamSound.pause(); // Il n'existe pas de méthode `stop()`.\n      // On doit donc faire une pause, puis\n      // remettre le curseur au début de la piste.\n\n      assets.diamSound.currentTime = 0;\n      assets.diamSound.play();\n      this.eatenDiams++;\n      console.log(this.eatenDiams, \"/\", this.level.need);\n\n      if (this.eatenDiams == this.level.need) {\n        this.level.setType(this.level.exitX, this.level.exitY, Level.EXIT);\n        assets.exitSound.play();\n      }\n\n      this.score += 50;\n\n      if (this.divDiam) {\n        this.divDiam.textContent = Math.max(0, this.level.need - this.eatenDiams);\n        this.divScore.textContent = this.score;\n      }\n    },\n    //#(eatDiam)\n    // Bruit du rocher dont la chute est stoppée par un obstacle.\n    playBoom: function playBoom() {\n      assets.rockSound.pause();\n      assets.rockSound.currentTime = 0;\n      assets.rockSound.play();\n    },\n    explode: function explode(col, row, makeDiams) {\n      var level = this.level;\n      var x, y;\n      this.makeDiams = makeDiams;\n\n      for (y = row - 1; y < row + 2; y++) {\n        for (x = col - 1; x < col + 2; x++) {\n          if (level.getType(x, y) !== Level.WALL && level.getType(x, y) !== Level.EXIT) {\n            level.setType(x, y, makeDiams ? Level.EXP2 : Level.EXP1);\n            level.setIndex(x, y, 1);\n            level.setMove(x, y, 0, 0);\n          }\n        }\n      }\n\n      assets.explSound.pause();\n      assets.explSound.currentTime = 0;\n      assets.explSound.play();\n    },\n    // Vie te mort du Héro.\n    isHeroAlive: true,\n    killHero: function killHero() {\n      if (!this.isHeroAlive) return;\n      this.camVX = this.camVY = 0;\n      this.isHeroAlive = false;\n      var col, row;\n\n      for (row = 0; row < this.level.rows; row++) {\n        for (col = 0; col < this.level.cols; col++) {\n          if (this.level.getType(col, row) === Level.HERO) {\n            this.explode(col, row);\n          }\n        }\n      }\n\n      this.wait = 4;\n    },\n    isLevelDone: false,\n    nextLevel: function nextLevel() {\n      this.isLevelDone = true;\n      this.killHero();\n    }\n  };\n}","map":{"version":3,"sources":["/home/tolokoban/Code/github/boulder-dash/src/lib/level-logic.ts"],"names":["createEnv","apply","process","isRockOrDiam","level","col","row","cell","getType","Level","ROCK","DIAM","isRockOrDiamOrWall","WALL","prepareMove","vx","vy","env","src","dst","HERO","killHero","setMove","setType","processFallingRockOrDiam","below","VOID","setVY","DUST","playBoom","MONS","explode","BOOM","processSteadyRockOrDiam","getVX","processRockOrDiam","setVX","falling","getVY","processExplosion1","getIndex","setIndex","processExplosion2","Math","floor","random","dirs","processMonster","dir","d","k","v","target","processHero","heroMoves","action","isHeroAlive","camX","camY","move","GameInputs","UP","RIGHT","DOWN","LEFT","SUICIDE","nextX","nextY","camVX","camVY","flag","push","rows","cols","hasFlag","unflag","EXP1","EXP2","forEach","eatDiam","EXIT","nextLevel","gl","assets","x","y","z","w","cellTime","nextSynchro","levelNumber","score","bonus","divDiam","document","getElementById","divScore","eatenDiams","diamSound","pause","currentTime","play","console","log","need","exitX","exitY","exitSound","textContent","max","rockSound","makeDiams","explSound","wait","isLevelDone"],"mappings":"AAAA,eAAe;AAAEA,EAAAA,SAAS,EAATA,SAAF;AAAaC,EAAAA,KAAK,EAALA,KAAb;AAAoBC,EAAAA,OAAO,EAAPA;AAApB,CAAf;;AAEA,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,GAA7B,EAAkCC,GAAlC,EAAuC;AACnC,MAAIC,IAAI,GAAGH,KAAK,CAACI,OAAN,CAAcH,GAAd,EAAmBC,GAAnB,CAAX;AACA,SAAOC,IAAI,KAAKE,KAAK,CAACC,IAAf,IAAuBH,IAAI,KAAKE,KAAK,CAACE,IAA7C;AACH;;AAED,SAASC,kBAAT,CAA4BR,KAA5B,EAAmCC,GAAnC,EAAwCC,GAAxC,EAA6C;AACzC,MAAIC,IAAI,GAAGH,KAAK,CAACI,OAAN,CAAcH,GAAd,EAAmBC,GAAnB,CAAX;AACA,SAAOC,IAAI,KAAKE,KAAK,CAACC,IAAf,IAAuBH,IAAI,KAAKE,KAAK,CAACE,IAAtC,IAA8CJ,IAAI,KAAKE,KAAK,CAACI,IAApE;AACH;;AAED,SAASC,WAAT,CAAqBT,GAArB,EAA0BC,GAA1B,EAA+BS,EAA/B,EAAmCC,EAAnC,EAAuCC,GAAvC,EAA4C;AACxC,MAAIF,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0B;AAC1B,MAAIZ,KAAK,GAAGa,GAAG,CAACb,KAAhB;AACA,MAAIc,GAAG,GAAGd,KAAK,CAACI,OAAN,CAAcH,GAAd,EAAmBC,GAAnB,CAAV;AACA,MAAIa,GAAG,GAAGf,KAAK,CAACI,OAAN,CAAcH,GAAG,GAAGU,EAApB,EAAwBT,GAAG,GAAGU,EAA9B,CAAV;AACA,MAAIG,GAAG,KAAKV,KAAK,CAACW,IAAlB,EAAwBH,GAAG,CAACI,QAAJ,GAAxB,KACK;AACDjB,IAAAA,KAAK,CAACkB,OAAN,CAAcjB,GAAd,EAAmBC,GAAnB,EAAwBS,EAAxB,EAA4BC,EAA5B;AACAZ,IAAAA,KAAK,CAACmB,OAAN,CAAclB,GAAG,GAAGU,EAApB,EAAwBT,GAAG,GAAGU,EAA9B,EAAkC,CAACE,GAAnC;AACH;AACJ;;AAAA;;AAED,SAASM,wBAAT,CAAkCpB,KAAlC,EAAyCC,GAAzC,EAA8CC,GAA9C,EAAmDW,GAAnD,EAAwDQ,KAAxD,EAA+D;AAC3D;AACA;AACA;AACA;AACA,MAAIA,KAAK,KAAKhB,KAAK,CAACiB,IAApB,EAA0B;AACtB;AACAtB,IAAAA,KAAK,CAACuB,KAAN,CAAYtB,GAAZ,EAAiBC,GAAjB,EAAsB,CAAtB;;AACA,QAAImB,KAAK,IAAIhB,KAAK,CAACC,IAAf,IAAuBe,KAAK,IAAIhB,KAAK,CAACI,IAAtC,IAA8CY,KAAK,IAAIhB,KAAK,CAACmB,IAAjE,EAAuE;AACnE;AACA;AACAX,MAAAA,GAAG,CAACY,QAAJ;AACH,KAJD,MAKK,IAAIJ,KAAK,IAAIhB,KAAK,CAACW,IAAnB,EAAyB;AAC1B;AACAH,MAAAA,GAAG,CAACI,QAAJ;AACH,KAHI,MAIA,IAAII,KAAK,IAAIhB,KAAK,CAACqB,IAAnB,EAAyB;AAC1B;AACA1B,MAAAA,KAAK,CAACmB,OAAN,CAAclB,GAAd,EAAmBC,GAAnB,EAAwBG,KAAK,CAACiB,IAA9B;AACAT,MAAAA,GAAG,CAACc,OAAJ,CAAY1B,GAAZ,EAAiBC,GAAG,GAAG,CAAvB,EAA0B,IAA1B;AACH,KAJI,MAKA,IAAImB,KAAK,IAAIhB,KAAK,CAACE,IAAnB,EAAyB;AAC1B;AACA,UAAIP,KAAK,CAACI,OAAN,CAAcH,GAAd,EAAmBC,GAAnB,MAA4BG,KAAK,CAACC,IAAtC,EAA4C;AACxCN,QAAAA,KAAK,CAACmB,OAAN,CAAclB,GAAd,EAAmBC,GAAnB,EAAwBG,KAAK,CAACiB,IAA9B;AACAT,QAAAA,GAAG,CAACc,OAAJ,CAAY1B,GAAZ,EAAiBC,GAAG,GAAG,CAAvB;AACH;AACJ;AACJ,GAxBD,MAwBO;AACHF,IAAAA,KAAK,CAACmB,OAAN,CAAclB,GAAd,EAAmBC,GAAG,GAAG,CAAzB,EAA4BG,KAAK,CAACuB,IAAlC;AACH;AACJ;;AAED,SAASC,uBAAT,CAAiC7B,KAAjC,EAAwCC,GAAxC,EAA6CC,GAA7C,EAAkDW,GAAlD,EAAuDQ,KAAvD,EAA8D;AAC1D;AACA,MAAIA,KAAK,KAAKhB,KAAK,CAACiB,IAApB,EAA0B;AACtBtB,IAAAA,KAAK,CAACkB,OAAN,CAAcjB,GAAd,EAAmBC,GAAnB,EAAwB,CAAxB,EAA2B,CAA3B;AACAF,IAAAA,KAAK,CAACmB,OAAN,CAAclB,GAAd,EAAmBC,GAAG,GAAG,CAAzB,EAA4BG,KAAK,CAACuB,IAAlC;AACH,GAHD,MAIK,IAAIpB,kBAAkB,CAACR,KAAD,EAAQC,GAAR,EAAaC,GAAG,GAAG,CAAnB,CAAtB,EAA6C;AAC9C,QAAI,CAACH,YAAY,CAACC,KAAD,EAAQC,GAAR,EAAaC,GAAG,GAAG,CAAnB,CAAjB,EAAwC;AACpC;AACA;AACA,UAAIF,KAAK,CAACI,OAAN,CAAcH,GAAG,GAAG,CAApB,EAAuBC,GAAvB,KAA+BG,KAAK,CAACiB,IAArC,IACGtB,KAAK,CAACI,OAAN,CAAcH,GAAG,GAAG,CAApB,EAAuBC,GAAG,GAAG,CAA7B,KAAmCG,KAAK,CAACiB,IAD5C,IAEG,CAACvB,YAAY,CAACC,KAAD,EAAQC,GAAG,GAAG,CAAd,EAAiBC,GAAG,GAAG,CAAvB,CAFpB,EAE+C;AAC3C;AACAF,QAAAA,KAAK,CAACkB,OAAN,CAAcjB,GAAd,EAAmBC,GAAnB,EAAwB,CAAC,CAAzB,EAA4B,CAA5B;AACH,OALD,MAMK,IAAIF,KAAK,CAACI,OAAN,CAAcH,GAAG,GAAG,CAApB,EAAuBC,GAAvB,KAA+BG,KAAK,CAACiB,IAArC,IACFtB,KAAK,CAACI,OAAN,CAAcH,GAAG,GAAG,CAApB,EAAuBC,GAAG,GAAG,CAA7B,KAAmCG,KAAK,CAACiB,IADvC,IAEF,CAACvB,YAAY,CAACC,KAAD,EAAQC,GAAG,GAAG,CAAd,EAAiBC,GAAG,GAAG,CAAvB,CAFf,EAE0C;AAC3C;AACA;AACA,YAAID,GAAG,GAAG,CAAN,IAAW,CAACF,YAAY,CAACC,KAAD,EAAQC,GAAG,GAAG,CAAd,EAAiBC,GAAjB,CAAxB,IAAiDF,KAAK,CAAC8B,KAAN,CAAY7B,GAAG,GAAG,CAAlB,EAAqBC,GAArB,IAA4B,CAAjF,EAAoF;AAChFF,UAAAA,KAAK,CAACkB,OAAN,CAAcjB,GAAd,EAAmBC,GAAnB,EAAwB,CAAC,CAAzB,EAA4B,CAA5B;AACH;AACJ;AACJ;AACJ;AACJ;;AAED,SAAS6B,iBAAT,CAA2B/B,KAA3B,EAAkCC,GAAlC,EAAuCC,GAAvC,EAA4CW,GAA5C,EAAiD;AAC7Cb,EAAAA,KAAK,CAACgC,KAAN,CAAY/B,GAAZ,EAAiBC,GAAjB,EAAsB,CAAtB,EAD6C,CACnB;;AAE1B,MAAImB,KAAK,GAAGrB,KAAK,CAACI,OAAN,CAAcH,GAAd,EAAmBC,GAAG,GAAG,CAAzB,CAAZ;AACA,MAAI+B,OAAO,GAAGjC,KAAK,CAACkC,KAAN,CAAYjC,GAAZ,EAAiBC,GAAjB,KAAyB,CAAvC;;AACA,MAAI+B,OAAJ,EAAa;AACTb,IAAAA,wBAAwB,CAACpB,KAAD,EAAQC,GAAR,EAAaC,GAAb,EAAkBW,GAAlB,EAAuBQ,KAAvB,CAAxB;AACH,GAFD,MAEO;AACHQ,IAAAA,uBAAuB,CAAC7B,KAAD,EAAQC,GAAR,EAAaC,GAAb,EAAkBW,GAAlB,EAAuBQ,KAAvB,CAAvB;AACH;AACJ;;AAED,SAASc,iBAAT,CAA2BtB,GAA3B,EAAgCb,KAAhC,EAAuCC,GAAvC,EAA4CC,GAA5C,EAAiD;AAC7C;AACA,MAAIF,KAAK,CAACoC,QAAN,CAAenC,GAAf,EAAoBC,GAApB,IAA2B,CAA/B,EAAkC;AAC9B;AACAF,IAAAA,KAAK,CAACqC,QAAN,CAAepC,GAAf,EAAoBC,GAApB,EAAyBF,KAAK,CAACoC,QAAN,CAAenC,GAAf,EAAoBC,GAApB,IAA2B,CAApD;AACH,GAHD,MAGO;AACH;AACAF,IAAAA,KAAK,CAACmB,OAAN,CAAclB,GAAd,EAAmBC,GAAnB,EAAwBG,KAAK,CAACiB,IAA9B;AACH;AACJ;;AAED,SAASgB,iBAAT,CAA2BzB,GAA3B,EAAgCb,KAAhC,EAAuCC,GAAvC,EAA4CC,GAA5C,EAAiD;AAC7C;AACA,MAAIF,KAAK,CAACoC,QAAN,CAAenC,GAAf,EAAoBC,GAApB,IAA2B,CAA/B,EAAkC;AAC9B;AACAF,IAAAA,KAAK,CAACqC,QAAN,CAAepC,GAAf,EAAoBC,GAApB,EAAyBF,KAAK,CAACoC,QAAN,CAAenC,GAAf,EAAoBC,GAApB,IAA2B,CAApD;AACH,GAHD,MAGO;AACH;AACAF,IAAAA,KAAK,CAACmB,OAAN,CAAclB,GAAd,EAAmBC,GAAnB,EAAwBG,KAAK,CAACE,IAA9B;AACAP,IAAAA,KAAK,CAACqC,QAAN,CAAepC,GAAf,EAAoBC,GAApB,EAAyBqC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB,EAA3B,CAAzB;AACH;AACJ,C,CAED;AACA;AACA;;;AACA,IAAMC,IAAI,GAAG,CAAC,CAAC,CAAD,EAAI,CAAC,CAAL,CAAD,EAAU,CAAC,CAAD,EAAI,CAAJ,CAAV,EAAkB,CAAC,CAAD,EAAI,CAAJ,CAAlB,EAA0B,CAAC,CAAC,CAAF,EAAK,CAAL,CAA1B,CAAb;;AACA,SAASC,cAAT,CAAwB9B,GAAxB,EAA6Bb,KAA7B,EAAoCC,GAApC,EAAyCC,GAAzC,EAA8C;AAC1C,MAAI0C,GAAG,GAAG5C,KAAK,CAACoC,QAAN,CAAenC,GAAf,EAAoBC,GAApB,CAAV;AACA,MAAI2C,CAAJ,EAAOC,CAAP;AACA,MAAInC,EAAJ,EAAQC,EAAR,EAAYmC,CAAZ;AACA,MAAIC,MAAJ;;AACA,OAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,CAAhB,EAAmBA,CAAC,EAApB,EAAwB;AACpBD,IAAAA,CAAC,GAAG,CAACD,GAAG,GAAGE,CAAP,IAAY,CAAhB;AACAC,IAAAA,CAAC,GAAGL,IAAI,CAACG,CAAD,CAAR;AACAlC,IAAAA,EAAE,GAAGoC,CAAC,CAAC,CAAD,CAAN;AACAnC,IAAAA,EAAE,GAAGmC,CAAC,CAAC,CAAD,CAAN;AACAC,IAAAA,MAAM,GAAGhD,KAAK,CAACI,OAAN,CAAcH,GAAG,GAAGU,EAApB,EAAwBT,GAAG,GAAGU,EAA9B,CAAT;;AACA,YAAQoC,MAAR;AACI,WAAK3C,KAAK,CAACiB,IAAX;AACIZ,QAAAA,WAAW,CAACT,GAAD,EAAMC,GAAN,EAAWS,EAAX,EAAeC,EAAf,EAAmBC,GAAnB,CAAX;AACAb,QAAAA,KAAK,CAACqC,QAAN,CAAepC,GAAf,EAAoBC,GAApB,EAAyB2C,CAAzB;AACA;;AACJ,WAAKxC,KAAK,CAACW,IAAX;AACIH,QAAAA,GAAG,CAACI,QAAJ;AACA;;AACJ,WAAKZ,KAAK,CAACC,IAAX;AACA,WAAKD,KAAK,CAACE,IAAX;AACI,YAAIsC,CAAC,IAAI,CAAT,EAAY;AACR;AACA;AACAhC,UAAAA,GAAG,CAACc,OAAJ,CAAY1B,GAAZ,EAAiBC,GAAjB,EAAsB,IAAtB;AACA;AACH;;AACD;;AACJ,WAAKG,KAAK,CAACuB,IAAX;AACIf,QAAAA,GAAG,CAACc,OAAJ,CAAY1B,GAAZ,EAAiBC,GAAjB,EAAsB,IAAtB;AACA;AAnBR;AAqBH;;AACDF,EAAAA,KAAK,CAACkB,OAAN,CAAcjB,GAAd,EAAmBC,GAAnB,EAAwB,CAAxB,EAA2B,CAA3B;AACH;;AAED,SAAS+C,WAAT,CAAqBpC,GAArB,EAA0Bb,KAA1B,EAAiCC,GAAjC,EAAsCC,GAAtC,EAA2CgD,SAA3C,EAAsDC,MAAtD,EAA8D;AAC1D;AACA,MAAI,CAACtC,GAAG,CAACuC,WAAT,EAAsB;AAClBvC,IAAAA,GAAG,CAACwC,IAAJ,GAAW,CAAX;AACAxC,IAAAA,GAAG,CAACyC,IAAJ,GAAW,CAAX;AACA;AACH;;AAED,MAAIC,IAAI,GAAG,IAAX;AAEA,MAAI5C,EAAE,GAAG,CAAT;AACA,MAAIC,EAAE,GAAG,CAAT;;AAEA,UAAQuC,MAAR;AACI,SAAKK,UAAU,CAACC,EAAhB;AACI9C,MAAAA,EAAE,GAAG,CAAL;AACAC,MAAAA,EAAE,GAAG,CAAC,CAAN;AACA;;AACJ,SAAK4C,UAAU,CAACE,KAAhB;AACI/C,MAAAA,EAAE,GAAG,CAAL;AACAC,MAAAA,EAAE,GAAG,CAAL;AACAZ,MAAAA,KAAK,CAACqC,QAAN,CAAepC,GAAf,EAAoBC,GAApB,EAAyB,CAAzB;AACA;;AACJ,SAAKsD,UAAU,CAACG,IAAhB;AACIhD,MAAAA,EAAE,GAAG,CAAL;AACAC,MAAAA,EAAE,GAAG,CAAL;AACA;;AACJ,SAAK4C,UAAU,CAACI,IAAhB;AACIjD,MAAAA,EAAE,GAAG,CAAC,CAAN;AACAC,MAAAA,EAAE,GAAG,CAAL;AACAZ,MAAAA,KAAK,CAACqC,QAAN,CAAepC,GAAf,EAAoBC,GAApB,EAAyB,CAAzB;AACA;;AACJ,SAAKsD,UAAU,CAACK,OAAhB;AACIhD,MAAAA,GAAG,CAACI,QAAJ;AACAsC,MAAAA,IAAI,GAAG,KAAP;AACA;;AACJ;AACIA,MAAAA,IAAI,GAAG,KAAP;AACA;AAzBR;;AA4BA,MAAIA,IAAJ,EAAU;AACN,QAAIO,KAAK,GAAG7D,GAAG,GAAGU,EAAlB;AACA,QAAIoD,KAAK,GAAG7D,GAAG,GAAGU,EAAlB;AACA,QAAIT,IAAI,GAAGH,KAAK,CAACI,OAAN,CAAc0D,KAAd,EAAqBC,KAArB,CAAX;;AACA,QAAI5D,IAAI,KAAKE,KAAK,CAACI,IAAf,IAAuBN,IAAI,KAAKE,KAAK,CAACW,IAA1C,EAAgD;AAC5C;AACAH,MAAAA,GAAG,CAACwC,IAAJ,GAAWpD,GAAX;AACAY,MAAAA,GAAG,CAACyC,IAAJ,GAAWpD,GAAX;AACAW,MAAAA,GAAG,CAACmD,KAAJ,GAAY,CAAZ;AACAnD,MAAAA,GAAG,CAACoD,KAAJ,GAAY,CAAZ;AACA;AACH;;AAED,QAAI9D,IAAI,KAAKE,KAAK,CAACC,IAAnB,EAAyB;AACrB;AACA;AACA,UAAIK,EAAE,KAAK,CAAC,CAAR,IAAaX,KAAK,CAACI,OAAN,CAAc0D,KAAK,GAAG,CAAtB,EAAyBC,KAAzB,MAAoC1D,KAAK,CAACiB,IAA3D,EAAiE;AAC7DtB,QAAAA,KAAK,CAACgC,KAAN,CAAY8B,KAAZ,EAAmBC,KAAnB,EAA0B,CAAC,CAA3B;AACA/D,QAAAA,KAAK,CAACkE,IAAN,CAAWJ,KAAX,EAAkBC,KAAlB;AACH,OAHD,MAIK,IAAIpD,EAAE,KAAK,CAAC,CAAR,IAAaX,KAAK,CAACI,OAAN,CAAc0D,KAAK,GAAG,CAAtB,EAAyBC,KAAzB,MAAoC1D,KAAK,CAACiB,IAA3D,EAAiE;AAClEtB,QAAAA,KAAK,CAACgC,KAAN,CAAY8B,KAAZ,EAAmBC,KAAnB,EAA0B,CAAC,CAA3B;AACH,OAToB,CAUrB;;;AACA/D,MAAAA,KAAK,CAACkB,OAAN,CAAcjB,GAAd,EAAmBC,GAAnB,EAAwB,CAAxB,EAA2B,CAA3B;AACAS,MAAAA,EAAE,GAAGC,EAAE,GAAG,CAAV;AACH,KAbD,MAcK;AACDsC,MAAAA,SAAS,CAACiB,IAAV,CAAe,CAAClE,GAAD,EAAMC,GAAN,CAAf;AACAF,MAAAA,KAAK,CAACkE,IAAN,CAAWJ,KAAX,EAAkBC,KAAlB;AACA/D,MAAAA,KAAK,CAACkB,OAAN,CAAcjB,GAAd,EAAmBC,GAAnB,EAAwBS,EAAxB,EAA4BC,EAA5B;AACH;AACJ;;AACDC,EAAAA,GAAG,CAACwC,IAAJ,GAAWpD,GAAX;AACAY,EAAAA,GAAG,CAACyC,IAAJ,GAAWpD,GAAX;AACAW,EAAAA,GAAG,CAACmD,KAAJ,GAAYrD,EAAZ;AACAE,EAAAA,GAAG,CAACoD,KAAJ,GAAYrD,EAAZ;AACH,C,CAID;;;AACA,SAASd,OAAT,CAAiBe,GAAjB,EAAsBsC,MAAtB,EAA8B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAID,SAAS,GAAG,EAAhB;AAEA,MAAIlD,KAAK,GAAGa,GAAG,CAACb,KAAhB;AACA,MAAIE,GAAJ,EAASD,GAAT,EAAcE,IAAd;;AACA,OAAKD,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAGF,KAAK,CAACoE,IAA1B,EAAgClE,GAAG,EAAnC,EAAuC;AACnC,SAAKD,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAGD,KAAK,CAACqE,IAA1B,EAAgCpE,GAAG,EAAnC,EAAuC;AACnC,UAAID,KAAK,CAACsE,OAAN,CAAcrE,GAAd,EAAmBC,GAAnB,CAAJ,EAA6B;AACzBF,QAAAA,KAAK,CAACuE,MAAN,CAAatE,GAAb,EAAkBC,GAAlB;AACA;AACH;;AAEDC,MAAAA,IAAI,GAAGH,KAAK,CAACI,OAAN,CAAcH,GAAd,EAAmBC,GAAnB,CAAP;;AACA,UAAIC,IAAI,KAAKE,KAAK,CAACC,IAAf,IAAuBH,IAAI,KAAKE,KAAK,CAACE,IAA1C,EAAgD;AAC5CwB,QAAAA,iBAAiB,CAAC/B,KAAD,EAAQC,GAAR,EAAaC,GAAb,EAAkBW,GAAlB,CAAjB;AACH,OAFD,MAGK,IAAIb,KAAK,CAACI,OAAN,CAAcH,GAAd,EAAmBC,GAAnB,MAA4BG,KAAK,CAACW,IAAtC,EAA4C;AAC7CiC,QAAAA,WAAW,CAACpC,GAAD,EAAMb,KAAN,EAAaC,GAAb,EAAkBC,GAAlB,EAAuBgD,SAAvB,EAAkCC,MAAlC,CAAX;AACH,OAFI,MAGA,IAAIhD,IAAI,KAAKE,KAAK,CAACqB,IAAnB,EAAyB;AAC1BiB,QAAAA,cAAc,CAAC9B,GAAD,EAAMb,KAAN,EAAaC,GAAb,EAAkBC,GAAlB,CAAd;AACH,OAFI,MAGA,IAAIC,IAAI,KAAKE,KAAK,CAACmE,IAAnB,EAAyB;AAC1BrC,QAAAA,iBAAiB,CAACtB,GAAD,EAAMb,KAAN,EAAaC,GAAb,EAAkBC,GAAlB,CAAjB;AACH,OAFI,MAGA,IAAIC,IAAI,KAAKE,KAAK,CAACoE,IAAnB,EAAyB;AAC1BnC,QAAAA,iBAAiB,CAACzB,GAAD,EAAMb,KAAN,EAAaC,GAAb,EAAkBC,GAAlB,CAAjB;AACH;AACJ;AACJ;;AACDgD,EAAAA,SAAS,CAACwB,OAAV,CAAkB,UAASnB,IAAT,EAAe;AAC7B,QAAItD,GAAG,GAAGsD,IAAI,CAAC,CAAD,CAAd;AACA,QAAIrD,GAAG,GAAGqD,IAAI,CAAC,CAAD,CAAd;AACA,QAAI5C,EAAE,GAAGX,KAAK,CAAC8B,KAAN,CAAY7B,GAAZ,EAAiBC,GAAjB,CAAT;AACA,QAAIU,EAAE,GAAGZ,KAAK,CAACkC,KAAN,CAAYjC,GAAZ,EAAiBC,GAAjB,CAAT;AACAD,IAAAA,GAAG,IAAIU,EAAP;AACAT,IAAAA,GAAG,IAAIU,EAAP;AACA,QAAIT,IAAI,GAAGH,KAAK,CAACI,OAAN,CAAcH,GAAd,EAAmBC,GAAnB,CAAX;;AACA,QAAIC,IAAI,KAAKE,KAAK,CAACmB,IAAnB,EAAyB;AACrBxB,MAAAA,KAAK,CAACmB,OAAN,CAAclB,GAAd,EAAmBC,GAAnB,EAAwBG,KAAK,CAACiB,IAA9B;AACH,KAFD,MAGK,IAAInB,IAAI,KAAKE,KAAK,CAACE,IAAnB,EAAyB;AAC1BM,MAAAA,GAAG,CAAC8D,OAAJ;AACA3E,MAAAA,KAAK,CAACmB,OAAN,CAAclB,GAAd,EAAmBC,GAAnB,EAAwBG,KAAK,CAACiB,IAA9B;AACH,KAHI,MAIA,IAAInB,IAAI,KAAKE,KAAK,CAACuE,IAAnB,EAAyB/D,GAAG,CAACgE,SAAJ,GAAzB,KACA,IAAI1E,IAAI,KAAKE,KAAK,CAACiB,IAAnB,EAAyBT,GAAG,CAACI,QAAJ;AACjC,GAjBD;AAmBH,C,CAED;;;AACA,SAASpB,KAAT,CAAegB,GAAf,EAAoB;AAChB,MAAIb,KAAK,GAAGa,GAAG,CAACb,KAAhB;AACA,MAAIE,GAAJ,EAASD,GAAT;AACA,MAAImD,WAAW,GAAG,KAAlB;;AACA,OAAKlD,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAGF,KAAK,CAACoE,IAA1B,EAAgClE,GAAG,EAAnC,EAAuC;AACnC,SAAKD,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAGD,KAAK,CAACqE,IAA1B,EAAgCpE,GAAG,EAAnC,EAAuC;AACnC,UAAID,KAAK,CAACI,OAAN,CAAcH,GAAd,EAAmBC,GAAnB,MAA4BG,KAAK,CAACW,IAAtC,EAA4CoC,WAAW,GAAG,IAAd;;AAC5C,UAAIpD,KAAK,CAACsE,OAAN,CAAcrE,GAAd,EAAmBC,GAAnB,CAAJ,EAA6B;AACzB;AACAF,QAAAA,KAAK,CAACuE,MAAN,CAAatE,GAAb,EAAkBC,GAAlB;AACA;AACH;;AACD,UAAIS,EAAE,GAAGX,KAAK,CAAC8B,KAAN,CAAY7B,GAAZ,EAAiBC,GAAjB,CAAT;AACA,UAAIU,EAAE,GAAGZ,KAAK,CAACkC,KAAN,CAAYjC,GAAZ,EAAiBC,GAAjB,CAAT;;AACA,UAAIS,EAAE,IAAI,CAAN,IAAWC,EAAE,IAAI,CAArB,EAAwB;AACpBZ,QAAAA,KAAK,CAACuD,IAAN,CAAWtD,GAAX,EAAgBC,GAAhB,EAAqBD,GAAG,GAAGU,EAA3B,EAA+BT,GAAG,GAAGU,EAArC;;AACA,YAAID,EAAE,GAAG,CAAL,IAAUC,EAAE,GAAG,CAAnB,EAAsB;AAClB;AACA;AACA;AACA;AACAZ,UAAAA,KAAK,CAACkE,IAAN,CAAWjE,GAAG,GAAGU,EAAjB,EAAqBT,GAAG,GAAGU,EAA3B;AACH;AACJ;AACJ;AACJ;;AACD,MAAI,CAACwC,WAAL,EAAkBvC,GAAG,CAACI,QAAJ;AACrB;;AAED,SAASrB,SAAT,CAAmBkF,EAAnB,EAAuBC,MAAvB,EAA+B;AAC3B,SAAO;AACHD,IAAAA,EAAE,EAAEA,EADD;AAEHC,IAAAA,MAAM,EAAEA,MAFL;AAGHC,IAAAA,CAAC,EAAE,CAHA;AAGGC,IAAAA,CAAC,EAAE,CAHN;AAGSC,IAAAA,CAAC,EAAE,CAHZ;AAGeC,IAAAA,CAAC,EAAE,CAHlB;AAIHC,IAAAA,QAAQ,EAAE,GAJP;AAIa;AAChBC,IAAAA,WAAW,EAAE,CAAC,CALX;AAMHC,IAAAA,WAAW,EAAE,CANV;AAOHC,IAAAA,KAAK,EAAE,CAPJ;AAQHC,IAAAA,KAAK,EAAE,CARJ;AASHC,IAAAA,OAAO,EAAEC,QAAQ,CAACC,cAAT,CAAwB,MAAxB,CATN;AAUHC,IAAAA,QAAQ,EAAEF,QAAQ,CAACC,cAAT,CAAwB,OAAxB,CAVP;AAWH;AACAE,IAAAA,UAAU,EAAE,CAZT;AAaHlB,IAAAA,OAAO,EAAE,mBAAW;AAChB;AACA;AACAI,MAAAA,MAAM,CAACe,SAAP,CAAiBC,KAAjB,GAHgB,CAIhB;AACA;AACA;;AACAhB,MAAAA,MAAM,CAACe,SAAP,CAAiBE,WAAjB,GAA+B,CAA/B;AACAjB,MAAAA,MAAM,CAACe,SAAP,CAAiBG,IAAjB;AACA,WAAKJ,UAAL;AACAK,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAKN,UAAjB,EAA6B,GAA7B,EAAkC,KAAK7F,KAAL,CAAWoG,IAA7C;;AACA,UAAI,KAAKP,UAAL,IAAmB,KAAK7F,KAAL,CAAWoG,IAAlC,EAAwC;AACpC,aAAKpG,KAAL,CAAWmB,OAAX,CAAmB,KAAKnB,KAAL,CAAWqG,KAA9B,EAAqC,KAAKrG,KAAL,CAAWsG,KAAhD,EAAuDjG,KAAK,CAACuE,IAA7D;AACAG,QAAAA,MAAM,CAACwB,SAAP,CAAiBN,IAAjB;AACH;;AACD,WAAKV,KAAL,IAAc,EAAd;;AACA,UAAI,KAAKE,OAAT,EAAkB;AACd,aAAKA,OAAL,CAAae,WAAb,GAA2BjE,IAAI,CAACkE,GAAL,CAAS,CAAT,EAAY,KAAKzG,KAAL,CAAWoG,IAAX,GAAkB,KAAKP,UAAnC,CAA3B;AACA,aAAKD,QAAL,CAAcY,WAAd,GAA4B,KAAKjB,KAAjC;AACH;AACJ,KAjCE;AAkCH;AACA;AACA9D,IAAAA,QAAQ,EAAE,oBAAW;AACjBsD,MAAAA,MAAM,CAAC2B,SAAP,CAAiBX,KAAjB;AACAhB,MAAAA,MAAM,CAAC2B,SAAP,CAAiBV,WAAjB,GAA+B,CAA/B;AACAjB,MAAAA,MAAM,CAAC2B,SAAP,CAAiBT,IAAjB;AACH,KAxCE;AAyCHtE,IAAAA,OAAO,EAAE,iBAAS1B,GAAT,EAAcC,GAAd,EAAmByG,SAAnB,EAA8B;AACnC,UAAI3G,KAAK,GAAG,KAAKA,KAAjB;AACA,UAAIgF,CAAJ,EAAOC,CAAP;AACA,WAAK0B,SAAL,GAAiBA,SAAjB;;AACA,WAAK1B,CAAC,GAAG/E,GAAG,GAAG,CAAf,EAAkB+E,CAAC,GAAG/E,GAAG,GAAG,CAA5B,EAA+B+E,CAAC,EAAhC,EAAoC;AAChC,aAAKD,CAAC,GAAG/E,GAAG,GAAG,CAAf,EAAkB+E,CAAC,GAAG/E,GAAG,GAAG,CAA5B,EAA+B+E,CAAC,EAAhC,EAAoC;AAChC,cAAIhF,KAAK,CAACI,OAAN,CAAc4E,CAAd,EAAiBC,CAAjB,MAAwB5E,KAAK,CAACI,IAA9B,IAAsCT,KAAK,CAACI,OAAN,CAAc4E,CAAd,EAAiBC,CAAjB,MAAwB5E,KAAK,CAACuE,IAAxE,EAA8E;AAC1E5E,YAAAA,KAAK,CAACmB,OAAN,CAAc6D,CAAd,EAAiBC,CAAjB,EAAoB0B,SAAS,GAAGtG,KAAK,CAACoE,IAAT,GAAgBpE,KAAK,CAACmE,IAAnD;AACAxE,YAAAA,KAAK,CAACqC,QAAN,CAAe2C,CAAf,EAAkBC,CAAlB,EAAqB,CAArB;AACAjF,YAAAA,KAAK,CAACkB,OAAN,CAAc8D,CAAd,EAAiBC,CAAjB,EAAoB,CAApB,EAAuB,CAAvB;AACH;AACJ;AACJ;;AACDF,MAAAA,MAAM,CAAC6B,SAAP,CAAiBb,KAAjB;AACAhB,MAAAA,MAAM,CAAC6B,SAAP,CAAiBZ,WAAjB,GAA+B,CAA/B;AACAjB,MAAAA,MAAM,CAAC6B,SAAP,CAAiBX,IAAjB;AACH,KAzDE;AA0DH;AACA7C,IAAAA,WAAW,EAAE,IA3DV;AA4DHnC,IAAAA,QAAQ,EAAE,oBAAW;AACjB,UAAI,CAAC,KAAKmC,WAAV,EAAuB;AAEvB,WAAKY,KAAL,GAAa,KAAKC,KAAL,GAAa,CAA1B;AAEA,WAAKb,WAAL,GAAmB,KAAnB;AACA,UAAInD,GAAJ,EAASC,GAAT;;AACA,WAAKA,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAG,KAAKF,KAAL,CAAWoE,IAA/B,EAAqClE,GAAG,EAAxC,EAA4C;AACxC,aAAKD,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAG,KAAKD,KAAL,CAAWqE,IAA/B,EAAqCpE,GAAG,EAAxC,EAA4C;AACxC,cAAI,KAAKD,KAAL,CAAWI,OAAX,CAAmBH,GAAnB,EAAwBC,GAAxB,MAAiCG,KAAK,CAACW,IAA3C,EAAiD;AAC7C,iBAAKW,OAAL,CAAa1B,GAAb,EAAkBC,GAAlB;AACH;AACJ;AACJ;;AACD,WAAK2G,IAAL,GAAY,CAAZ;AACH,KA3EE;AA4EHC,IAAAA,WAAW,EAAE,KA5EV;AA6EHjC,IAAAA,SAAS,EAAE,qBAAW;AAClB,WAAKiC,WAAL,GAAmB,IAAnB;AACA,WAAK7F,QAAL;AACH;AAhFE,GAAP;AAkFH","sourcesContent":["export default { createEnv, apply, process };\n\nfunction isRockOrDiam(level, col, row) {\n    var cell = level.getType(col, row);\n    return cell === Level.ROCK || cell === Level.DIAM;\n}\n\nfunction isRockOrDiamOrWall(level, col, row) {\n    var cell = level.getType(col, row);\n    return cell === Level.ROCK || cell === Level.DIAM || cell === Level.WALL;\n}\n\nfunction prepareMove(col, row, vx, vy, env) {\n    if (vx === 0 && vy === 0) return;\n    var level = env.level;\n    var src = level.getType(col, row);\n    var dst = level.getType(col + vx, row + vy);\n    if (dst === Level.HERO) env.killHero();\n    else {\n        level.setMove(col, row, vx, vy);\n        level.setType(col + vx, row + vy, -src);\n    }\n};\n\nfunction processFallingRockOrDiam(level, col, row, env, below) {\n    // La pierre est déjà en train de tomber.\n    // On regarde s'il y a autre chose que du vide dessous. Si c'est\n    // le cas, la chute est stoppée,  mais il peut aussi y avoir des\n    // conséquences sur l'élément qui se trouvait en dessous.\n    if (below !== Level.VOID) {\n        // On arrête la chute dans tous les cas.\n        level.setVY(col, row, 0);\n        if (below == Level.ROCK || below == Level.WALL || below == Level.DUST) {\n            // Le rocher  (ou diamant)  a été  stoppé :  on joue  un son\n            // adéquat.\n            env.playBoom();\n        }\n        else if (below == Level.HERO) {\n            // On tombe sur le héro : ça le tue.\n            env.killHero();\n        }\n        else if (below == Level.MONS) {\n            // On écrase un monstre.\n            level.setType(col, row, Level.VOID);\n            env.explode(col, row + 1, true);\n        }\n        else if (below == Level.DIAM) {\n            // Si c'est une pierre qui tombe sur un diamant, il explose.\n            if (level.getType(col, row) === Level.ROCK) {\n                level.setType(col, row, Level.VOID);\n                env.explode(col, row + 1);\n            }\n        }\n    } else {\n        level.setType(col, row + 1, Level.BOOM);\n    }\n}\n\nfunction processSteadyRockOrDiam(level, col, row, env, below) {\n    // La pierre est au repos.\n    if (below === Level.VOID) {\n        level.setMove(col, row, 0, 1);\n        level.setType(col, row + 1, Level.BOOM);\n    }\n    else if (isRockOrDiamOrWall(level, col, row + 1)) {\n        if (!isRockOrDiam(level, col, row - 1)) {\n            // Si un rocher est posé sur un autre  et qu'il n'est pas sous un rocher/diamant, alors il\n            // peut basculer à droite ou à gauche si l'espace est libre.\n            if (level.getType(col + 1, row) == Level.VOID\n                && level.getType(col + 1, row + 1) == Level.VOID\n                && !isRockOrDiam(level, col + 1, row - 1)) {\n                // On tombe sur la droite.\n                level.setMove(col, row, +1, 0);\n            }\n            else if (level.getType(col - 1, row) == Level.VOID\n                && level.getType(col - 1, row + 1) == Level.VOID\n                && !isRockOrDiam(level, col - 1, row - 1)) {\n                // On tombe sur la gauche seulement s'il n'y a pas déjà un\n                // rocher qui tombe sur la droite juste en face.\n                if (col < 2 || !isRockOrDiam(level, col - 2, row) || level.getVX(col - 2, row) < 1) {\n                    level.setMove(col, row, -1, 0);\n                }\n            }\n        }\n    }\n}\n\nfunction processRockOrDiam(level, col, row, env) {\n    level.setVX(col, row, 0); // On arrête tout déplacement horizontal.\n\n    var below = level.getType(col, row + 1);\n    var falling = level.getVY(col, row) != 0;\n    if (falling) {\n        processFallingRockOrDiam(level, col, row, env, below);\n    } else {\n        processSteadyRockOrDiam(level, col, row, env, below);\n    }\n}\n\nfunction processExplosion1(env, level, col, row) {\n    // Une explosion a une durée de vie de 2 cycles.\n    if (level.getIndex(col, row) > 0) {\n        // Encore un cycle...\n        level.setIndex(col, row, level.getIndex(col, row) - 1);\n    } else {\n        // C'est terminé pour l'explosion.\n        level.setType(col, row, Level.VOID);\n    }\n}\n\nfunction processExplosion2(env, level, col, row) {\n    // Une explosion a une durée de vie de 2 cycles.\n    if (level.getIndex(col, row) > 0) {\n        // Encore un cycle...\n        level.setIndex(col, row, level.getIndex(col, row) - 1);\n    } else {\n        // C'est terminé pour l'explosion.\n        level.setType(col, row, Level.DIAM);\n        level.setIndex(col, row, Math.floor(Math.random() * 16));\n    }\n}\n\n// Directions du monstre en fonction de attIndex.\n// Il essaie  d'aller dans sa  direction et si c'est  impossible, il\n// essaie sur sa droite et ainsi de suite...\nconst dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];\nfunction processMonster(env, level, col, row) {\n    var dir = level.getIndex(col, row);\n    var d, k;\n    var vx, vy, v;\n    var target;\n    for (k = 5; k > 1; k--) {\n        d = (dir + k) % 4;\n        v = dirs[d];\n        vx = v[0];\n        vy = v[1];\n        target = level.getType(col + vx, row + vy);\n        switch (target) {\n            case Level.VOID:\n                prepareMove(col, row, vx, vy, env);\n                level.setIndex(col, row, d);\n                return;\n            case Level.HERO:\n                env.killHero();\n                return;\n            case Level.ROCK:\n            case Level.DIAM:\n                if (d == 0) {\n                    // Si on  monte vers  une pierre,  c'est qu'elle  nous fonce\n                    // dessus.\n                    env.explode(col, row, true);\n                    return;\n                }\n                break;\n            case Level.BOOM:\n                env.explode(col, row, true);\n                return;\n        }\n    }\n    level.setMove(col, row, 0, 0);\n}\n\nfunction processHero(env, level, col, row, heroMoves, action) {\n    // Si le héro est mort, on ne fait rien du tout.\n    if (!env.isHeroAlive) {\n        env.camX = 0;\n        env.camY = 0;\n        return;\n    }\n\n    var move = true;\n\n    var vx = 0;\n    var vy = 0;\n\n    switch (action) {\n        case GameInputs.UP:\n            vx = 0;\n            vy = -1;\n            break;\n        case GameInputs.RIGHT:\n            vx = 1;\n            vy = 0;\n            level.setIndex(col, row, 0);\n            break;\n        case GameInputs.DOWN:\n            vx = 0;\n            vy = 1;\n            break;\n        case GameInputs.LEFT:\n            vx = -1;\n            vy = 0;\n            level.setIndex(col, row, 1);\n            break;\n        case GameInputs.SUICIDE:\n            env.killHero();\n            move = false;\n            break;\n        default:\n            move = false;\n            break;\n    }\n\n    if (move) {\n        var nextX = col + vx;\n        var nextY = row + vy;\n        var cell = level.getType(nextX, nextY);\n        if (cell === Level.WALL || cell === Level.HERO) {\n            // Les murs arrêtent le déplacement. Les clones aussi.\n            env.camX = col;\n            env.camY = row;\n            env.camVX = 0;\n            env.camVY = 0;\n            return;\n        }\n\n        if (cell === Level.ROCK) {\n            // Les rochers aussi, mais ils  peuvent être poussés s'ils ont\n            // un espace vide derrière eux.\n            if (vx === +1 && level.getType(nextX + 1, nextY) === Level.VOID) {\n                level.setVX(nextX, nextY, +1);\n                level.flag(nextX, nextY);\n            }\n            else if (vx === -1 && level.getType(nextX - 1, nextY) === Level.VOID) {\n                level.setVX(nextX, nextY, -1);\n            }\n            // Le héro s'arrête net parce que le rocher est lourd.\n            level.setMove(col, row, 0, 0);\n            vx = vy = 0;\n        }\n        else {\n            heroMoves.push([col, row]);\n            level.flag(nextX, nextY);\n            level.setMove(col, row, vx, vy);\n        }\n    }\n    env.camX = col;\n    env.camY = row;\n    env.camVX = vx;\n    env.camVY = vy;\n}\n\n\n\n// Déterminer les déplacements futurs.\nfunction process(env, action) {\n    // Chaque héro peut manger de la terres (feuilles), mais il faut\n    // la retirer dans  un deuxième temps pour éviter  des effets de\n    // bord sur la chute de pierres vers la gauche.\n    // En effet, si on a une pile de pierre à deux cases à droite du\n    // héro et  que ce dernier  creuse juste à droite,  la prochaine\n    // case analysée sera celle de la pierre et on verra qu'il n'y a\n    // plus rien  à gauche, alors  qu'en réalité, c'est le  héro qui\n    // est censé prendre cette place.\n    // Le résultat  sera que  la pierre  et le  héro auront  la même\n    // cellule comme destination.\n    // `heroMoves` contient les coordonnées du héro.\n    var heroMoves = [];\n\n    var level = env.level;\n    var row, col, cell;\n    for (row = 0; row < level.rows; row++) {\n        for (col = 0; col < level.cols; col++) {\n            if (level.hasFlag(col, row)) {\n                level.unflag(col, row);\n                continue;\n            }\n\n            cell = level.getType(col, row);\n            if (cell === Level.ROCK || cell === Level.DIAM) {\n                processRockOrDiam(level, col, row, env);\n            }\n            else if (level.getType(col, row) === Level.HERO) {\n                processHero(env, level, col, row, heroMoves, action);\n            }\n            else if (cell === Level.MONS) {\n                processMonster(env, level, col, row);\n            }\n            else if (cell === Level.EXP1) {\n                processExplosion1(env, level, col, row);\n            }\n            else if (cell === Level.EXP2) {\n                processExplosion2(env, level, col, row);\n            }\n        }\n    }\n    heroMoves.forEach(function(move) {\n        var col = move[0];\n        var row = move[1];\n        var vx = level.getVX(col, row);\n        var vy = level.getVY(col, row);\n        col += vx;\n        row += vy;\n        var cell = level.getType(col, row);\n        if (cell === Level.DUST) {\n            level.setType(col, row, Level.VOID);\n        }\n        else if (cell === Level.DIAM) {\n            env.eatDiam();\n            level.setType(col, row, Level.VOID);\n        }\n        else if (cell === Level.EXIT) env.nextLevel();\n        else if (cell !== Level.VOID) env.killHero();\n    });\n\n}\n\n// Appliquer les déplacements de chaque cellule.\nfunction apply(env) {\n    var level = env.level;\n    var row, col;\n    var isHeroAlive = false;\n    for (row = 0; row < level.rows; row++) {\n        for (col = 0; col < level.cols; col++) {\n            if (level.getType(col, row) === Level.HERO) isHeroAlive = true;\n            if (level.hasFlag(col, row)) {\n                // Cellule avec un flag : il ne faut pas la traiter.\n                level.unflag(col, row);\n                continue;\n            }\n            var vx = level.getVX(col, row);\n            var vy = level.getVY(col, row);\n            if (vx != 0 || vy != 0) {\n                level.move(col, row, col + vx, row + vy);\n                if (vx > 0 || vy > 0) {\n                    // On  flag une  cellule  si  elle est  à  droite ou  en\n                    // dessous de  la cellule courante.  Cela  évitera de la\n                    // prendre  en compte  une  deuxième fois  dans le  même\n                    // cycle.\n                    level.flag(col + vx, row + vy);\n                }\n            }\n        }\n    }\n    if (!isHeroAlive) env.killHero();\n}\n\nfunction createEnv(gl, assets) {\n    return {\n        gl: gl,\n        assets: assets,\n        x: 0, y: 0, z: 0, w: 1,\n        cellTime: 180,  // Temps en ms pour traverser une cellule.\n        nextSynchro: -1,\n        levelNumber: 0,\n        score: 0,\n        bonus: 0,\n        divDiam: document.getElementById(\"diam\"),\n        divScore: document.getElementById(\"score\"),\n        //#(eatDiam)\n        eatenDiams: 0,\n        eatDiam: function() {\n            // Les assets finissant par 'ogg', 'mp3' ou 'wav'\n            // sont transpformés en tag AUDIO.\n            assets.diamSound.pause();\n            // Il n'existe pas de méthode `stop()`.\n            // On doit donc faire une pause, puis\n            // remettre le curseur au début de la piste.\n            assets.diamSound.currentTime = 0;\n            assets.diamSound.play();\n            this.eatenDiams++;\n            console.log(this.eatenDiams, \"/\", this.level.need);\n            if (this.eatenDiams == this.level.need) {\n                this.level.setType(this.level.exitX, this.level.exitY, Level.EXIT);\n                assets.exitSound.play();\n            }\n            this.score += 50;\n            if (this.divDiam) {\n                this.divDiam.textContent = Math.max(0, this.level.need - this.eatenDiams);\n                this.divScore.textContent = this.score;\n            }\n        },\n        //#(eatDiam)\n        // Bruit du rocher dont la chute est stoppée par un obstacle.\n        playBoom: function() {\n            assets.rockSound.pause();\n            assets.rockSound.currentTime = 0;\n            assets.rockSound.play();\n        },\n        explode: function(col, row, makeDiams) {\n            var level = this.level;\n            var x, y;\n            this.makeDiams = makeDiams;\n            for (y = row - 1; y < row + 2; y++) {\n                for (x = col - 1; x < col + 2; x++) {\n                    if (level.getType(x, y) !== Level.WALL && level.getType(x, y) !== Level.EXIT) {\n                        level.setType(x, y, makeDiams ? Level.EXP2 : Level.EXP1);\n                        level.setIndex(x, y, 1);\n                        level.setMove(x, y, 0, 0);\n                    }\n                }\n            }\n            assets.explSound.pause();\n            assets.explSound.currentTime = 0;\n            assets.explSound.play();\n        },\n        // Vie te mort du Héro.\n        isHeroAlive: true,\n        killHero: function() {\n            if (!this.isHeroAlive) return;\n\n            this.camVX = this.camVY = 0;\n\n            this.isHeroAlive = false;\n            var col, row;\n            for (row = 0; row < this.level.rows; row++) {\n                for (col = 0; col < this.level.cols; col++) {\n                    if (this.level.getType(col, row) === Level.HERO) {\n                        this.explode(col, row);\n                    }\n                }\n            }\n            this.wait = 4;\n        },\n        isLevelDone: false,\n        nextLevel: function() {\n            this.isLevelDone = true;\n            this.killHero();\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"export default {\n  createEnv: createEnv\n};\n\nfunction isRockOrDiam(level, col, row) {\n  var cell = level.getType(col, row);\n  return cell === Level.ROCK || cell === Level.DIAM;\n}\n\nfunction isRockOrDiamOrWall(level, col, row) {\n  var cell = level.getType(col, row);\n  return cell === Level.ROCK || cell === Level.DIAM || cell === Level.WALL;\n}\n\nfunction prepareMove(col, row, vx, vy, env) {\n  if (vx === 0 && vy === 0) return;\n  var level = env.level;\n  var src = level.getType(col, row);\n  var dst = level.getType(col + vx, row + vy);\n  if (dst === Level.HERO) env.killHero();else {\n    level.setMove(col, row, vx, vy);\n    level.setType(col + vx, row + vy, -src);\n  }\n}\n\n;\n\nfunction processFallingRockOrDiam(level, col, row, env, below) {\n  // La pierre est déjà en train de tomber.\n  // On regarde s'il y a autre chose que du vide dessous. Si c'est\n  // le cas, la chute est stoppée,  mais il peut aussi y avoir des\n  // conséquences sur l'élément qui se trouvait en dessous.\n  if (below !== Level.VOID) {\n    // On arrête la chute dans tous les cas.\n    level.setVY(col, row, 0);\n\n    if (below == Level.ROCK || below == Level.WALL || below == Level.DUST) {\n      // Le rocher  (ou diamant)  a été  stoppé :  on joue  un son\n      // adéquat.\n      env.playBoom();\n    } else if (below == Level.HERO) {\n      // On tombe sur le héro : ça le tue.\n      env.killHero();\n    } else if (below == Level.MONS) {\n      // On écrase un monstre.\n      level.setType(col, row, Level.VOID);\n      env.explode(col, row + 1, true);\n    } else if (below == Level.DIAM) {\n      // Si c'est une pierre qui tombe sur un diamant, il explose.\n      if (level.getType(col, row) === Level.ROCK) {\n        level.setType(col, row, Level.VOID);\n        env.explode(col, row + 1);\n      }\n    }\n  } else {\n    level.setType(col, row + 1, Level.BOOM);\n  }\n}\n\nfunction processSteadyRockOrDiam(level, col, row, env, below) {\n  // La pierre est au repos.\n  if (below === Level.VOID) {\n    level.setMove(col, row, 0, 1);\n    level.setType(col, row + 1, Level.BOOM);\n  } else if (isRockOrDiamOrWall(level, col, row + 1)) {\n    if (!isRockOrDiam(level, col, row - 1)) {\n      // Si un rocher est posé sur un autre  et qu'il n'est pas sous un rocher/diamant, alors il\n      // peut basculer à droite ou à gauche si l'espace est libre.\n      if (level.getType(col + 1, row) == Level.VOID && level.getType(col + 1, row + 1) == Level.VOID && !isRockOrDiam(level, col + 1, row - 1)) {\n        // On tombe sur la droite.\n        level.setMove(col, row, +1, 0);\n      } else if (level.getType(col - 1, row) == Level.VOID && level.getType(col - 1, row + 1) == Level.VOID && !isRockOrDiam(level, col - 1, row - 1)) {\n        // On tombe sur la gauche seulement s'il n'y a pas déjà un\n        // rocher qui tombe sur la droite juste en face.\n        if (col < 2 || !isRockOrDiam(level, col - 2, row) || level.getVX(col - 2, row) < 1) {\n          level.setMove(col, row, -1, 0);\n        }\n      }\n    }\n  }\n}\n\nfunction processRockOrDiam(level, col, row, env) {\n  level.setVX(col, row, 0); // On arrête tout déplacement horizontal.\n\n  var below = level.getType(col, row + 1);\n  var falling = level.getVY(col, row) != 0;\n\n  if (falling) {\n    processFallingRockOrDiam(level, col, row, env, below);\n  } else {\n    processSteadyRockOrDiam(level, col, row, env, below);\n  }\n}\n\nfunction processExplosion1(env, level, col, row) {\n  // Une explosion a une durée de vie de 2 cycles.\n  if (level.getIndex(col, row) > 0) {\n    // Encore un cycle...\n    level.setIndex(col, row, level.getIndex(col, row) - 1);\n  } else {\n    // C'est terminé pour l'explosion.\n    level.setType(col, row, Level.VOID);\n  }\n}\n\nfunction processExplosion2(env, level, col, row) {\n  // Une explosion a une durée de vie de 2 cycles.\n  if (level.getIndex(col, row) > 0) {\n    // Encore un cycle...\n    level.setIndex(col, row, level.getIndex(col, row) - 1);\n  } else {\n    // C'est terminé pour l'explosion.\n    level.setType(col, row, Level.DIAM);\n    level.setIndex(col, row, Math.floor(Math.random() * 16));\n  }\n} // Directions du monstre en fonction de attIndex.\n// Il essaie  d'aller dans sa  direction et si c'est  impossible, il\n// essaie sur sa droite et ainsi de suite...\n\n\nvar dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];\n\nfunction processMonster(env, level, col, row) {\n  var dir = level.getIndex(col, row);\n  var d, k;\n  var vx, vy, v;\n  var target;\n\n  for (k = 5; k > 1; k--) {\n    d = (dir + k) % 4;\n    v = dirs[d];\n    vx = v[0];\n    vy = v[1];\n    target = level.getType(col + vx, row + vy);\n\n    switch (target) {\n      case Level.VOID:\n        prepareMove(col, row, vx, vy, env);\n        level.setIndex(col, row, d);\n        return;\n\n      case Level.HERO:\n        env.killHero();\n        return;\n\n      case Level.ROCK:\n      case Level.DIAM:\n        if (d == 0) {\n          // Si on  monte vers  une pierre,  c'est qu'elle  nous fonce\n          // dessus.\n          env.explode(col, row, true);\n          return;\n        }\n\n        break;\n\n      case Level.BOOM:\n        env.explode(col, row, true);\n        return;\n    }\n  }\n\n  level.setMove(col, row, 0, 0);\n}\n\nfunction processHero(env, level, col, row, heroMoves, action) {\n  // Si le héro est mort, on ne fait rien du tout.\n  if (!env.isHeroAlive) {\n    env.camX = 0;\n    env.camY = 0;\n    return;\n  }\n\n  var move = true;\n  var vx = 0;\n  var vy = 0;\n\n  switch (action) {\n    case GameInputs.UP:\n      vx = 0;\n      vy = -1;\n      break;\n\n    case GameInputs.RIGHT:\n      vx = 1;\n      vy = 0;\n      level.setIndex(col, row, 0);\n      break;\n\n    case GameInputs.DOWN:\n      vx = 0;\n      vy = 1;\n      break;\n\n    case GameInputs.LEFT:\n      vx = -1;\n      vy = 0;\n      level.setIndex(col, row, 1);\n      break;\n\n    case GameInputs.SUICIDE:\n      env.killHero();\n      move = false;\n      break;\n\n    default:\n      move = false;\n      break;\n  }\n\n  if (move) {\n    var nextX = col + vx;\n    var nextY = row + vy;\n    var cell = level.getType(nextX, nextY);\n\n    if (cell === Level.WALL || cell === Level.HERO) {\n      // Les murs arrêtent le déplacement. Les clones aussi.\n      env.camX = col;\n      env.camY = row;\n      env.camVX = 0;\n      env.camVY = 0;\n      return;\n    }\n\n    if (cell === Level.ROCK) {\n      // Les rochers aussi, mais ils  peuvent être poussés s'ils ont\n      // un espace vide derrière eux.\n      if (vx === +1 && level.getType(nextX + 1, nextY) === Level.VOID) {\n        level.setVX(nextX, nextY, +1);\n        level.flag(nextX, nextY);\n      } else if (vx === -1 && level.getType(nextX - 1, nextY) === Level.VOID) {\n        level.setVX(nextX, nextY, -1);\n      } // Le héro s'arrête net parce que le rocher est lourd.\n\n\n      level.setMove(col, row, 0, 0);\n      vx = vy = 0;\n    } else {\n      heroMoves.push([col, row]);\n      level.flag(nextX, nextY);\n      level.setMove(col, row, vx, vy);\n    }\n  }\n\n  env.camX = col;\n  env.camY = row;\n  env.camVX = vx;\n  env.camVY = vy;\n} // Déterminer les déplacements futurs.\n\n\nfunction process(env, action) {\n  // Chaque héro peut manger de la terres (feuilles), mais il faut\n  // la retirer dans  un deuxième temps pour éviter  des effets de\n  // bord sur la chute de pierres vers la gauche.\n  // En effet, si on a une pile de pierre à deux cases à droite du\n  // héro et  que ce dernier  creuse juste à droite,  la prochaine\n  // case analysée sera celle de la pierre et on verra qu'il n'y a\n  // plus rien  à gauche, alors  qu'en réalité, c'est le  héro qui\n  // est censé prendre cette place.\n  // Le résultat  sera que  la pierre  et le  héro auront  la même\n  // cellule comme destination.\n  // `heroMoves` contient les coordonnées du héro.\n  var heroMoves = [];\n  var level = env.level;\n  var row, col, cell;\n\n  for (row = 0; row < level.rows; row++) {\n    for (col = 0; col < level.cols; col++) {\n      if (level.hasFlag(col, row)) {\n        level.unflag(col, row);\n        continue;\n      }\n\n      cell = level.getType(col, row);\n\n      if (cell === Level.ROCK || cell === Level.DIAM) {\n        processRockOrDiam(level, col, row, env);\n      } else if (level.getType(col, row) === Level.HERO) {\n        processHero(env, level, col, row, heroMoves, action);\n      } else if (cell === Level.MONS) {\n        processMonster(env, level, col, row);\n      } else if (cell === Level.EXP1) {\n        processExplosion1(env, level, col, row);\n      } else if (cell === Level.EXP2) {\n        processExplosion2(env, level, col, row);\n      }\n    }\n  }\n\n  heroMoves.forEach(function (move) {\n    var col = move[0];\n    var row = move[1];\n    var vx = level.getVX(col, row);\n    var vy = level.getVY(col, row);\n    col += vx;\n    row += vy;\n    var cell = level.getType(col, row);\n\n    if (cell === Level.DUST) {\n      level.setType(col, row, Level.VOID);\n    } else if (cell === Level.DIAM) {\n      env.eatDiam();\n      level.setType(col, row, Level.VOID);\n    } else if (cell === Level.EXIT) env.nextLevel();else if (cell !== Level.VOID) env.killHero();\n  });\n} // Appliquer les déplacements de chaque cellule.\n\n\nfunction apply(env) {\n  var level = env.level;\n  var row, col;\n  var isHeroAlive = false;\n\n  for (row = 0; row < level.rows; row++) {\n    for (col = 0; col < level.cols; col++) {\n      if (level.getType(col, row) === Level.HERO) isHeroAlive = true;\n\n      if (level.hasFlag(col, row)) {\n        // Cellule avec un flag : il ne faut pas la traiter.\n        level.unflag(col, row);\n        continue;\n      }\n\n      var vx = level.getVX(col, row);\n      var vy = level.getVY(col, row);\n\n      if (vx != 0 || vy != 0) {\n        level.move(col, row, col + vx, row + vy);\n\n        if (vx > 0 || vy > 0) {\n          // On  flag une  cellule  si  elle est  à  droite ou  en\n          // dessous de  la cellule courante.  Cela  évitera de la\n          // prendre  en compte  une  deuxième fois  dans le  même\n          // cycle.\n          level.flag(col + vx, row + vy);\n        }\n      }\n    }\n  }\n\n  if (!isHeroAlive) env.killHero();\n}\n\nfunction createEnv(gl, assets) {\n  return {\n    gl: gl,\n    assets: assets,\n    x: 0,\n    y: 0,\n    z: 0,\n    w: 1,\n    cellTime: 180,\n    // Temps en ms pour traverser une cellule.\n    nextSynchro: -1,\n    levelNumber: 0,\n    score: 0,\n    bonus: 0,\n    divDiam: document.getElementById(\"diam\"),\n    divScore: document.getElementById(\"score\"),\n    //#(eatDiam)\n    eatenDiams: 0,\n    eatDiam: function eatDiam() {\n      // Les assets finissant par 'ogg', 'mp3' ou 'wav'\n      // sont transpformés en tag AUDIO.\n      assets.diamSound.pause(); // Il n'existe pas de méthode `stop()`.\n      // On doit donc faire une pause, puis\n      // remettre le curseur au début de la piste.\n\n      assets.diamSound.currentTime = 0;\n      assets.diamSound.play();\n      this.eatenDiams++;\n      console.log(this.eatenDiams, \"/\", this.level.need);\n\n      if (this.eatenDiams == this.level.need) {\n        this.level.setType(this.level.exitX, this.level.exitY, Level.EXIT);\n        assets.exitSound.play();\n      }\n\n      this.score += 50;\n\n      if (this.divDiam) {\n        this.divDiam.textContent = Math.max(0, this.level.need - this.eatenDiams);\n        this.divScore.textContent = this.score;\n      }\n    },\n    //#(eatDiam)\n    // Bruit du rocher dont la chute est stoppée par un obstacle.\n    playBoom: function playBoom() {\n      assets.rockSound.pause();\n      assets.rockSound.currentTime = 0;\n      assets.rockSound.play();\n    },\n    explode: function explode(col, row, makeDiams) {\n      var level = this.level;\n      var x, y;\n      this.makeDiams = makeDiams;\n\n      for (y = row - 1; y < row + 2; y++) {\n        for (x = col - 1; x < col + 2; x++) {\n          if (level.getType(x, y) !== Level.WALL && level.getType(x, y) !== Level.EXIT) {\n            level.setType(x, y, makeDiams ? Level.EXP2 : Level.EXP1);\n            level.setIndex(x, y, 1);\n            level.setMove(x, y, 0, 0);\n          }\n        }\n      }\n\n      assets.explSound.pause();\n      assets.explSound.currentTime = 0;\n      assets.explSound.play();\n    },\n    // Vie te mort du Héro.\n    isHeroAlive: true,\n    killHero: function killHero() {\n      if (!this.isHeroAlive) return;\n      this.camVX = this.camVY = 0;\n      this.isHeroAlive = false;\n      var col, row;\n\n      for (row = 0; row < this.level.rows; row++) {\n        for (col = 0; col < this.level.cols; col++) {\n          if (this.level.getType(col, row) === Level.HERO) {\n            this.explode(col, row);\n          }\n        }\n      }\n\n      this.wait = 4;\n    },\n    isLevelDone: false,\n    nextLevel: function nextLevel() {\n      this.isLevelDone = true;\n      this.killHero();\n    }\n  };\n}","map":{"version":3,"sources":["/home/tolokoban/Code/github/boulder-dash/src/lib/level-logic.ts"],"names":["createEnv","isRockOrDiam","level","col","row","cell","getType","Level","ROCK","DIAM","isRockOrDiamOrWall","WALL","prepareMove","vx","vy","env","src","dst","HERO","killHero","setMove","setType","processFallingRockOrDiam","below","VOID","setVY","DUST","playBoom","MONS","explode","BOOM","processSteadyRockOrDiam","getVX","processRockOrDiam","setVX","falling","getVY","processExplosion1","getIndex","setIndex","processExplosion2","Math","floor","random","dirs","processMonster","dir","d","k","v","target","processHero","heroMoves","action","isHeroAlive","camX","camY","move","GameInputs","UP","RIGHT","DOWN","LEFT","SUICIDE","nextX","nextY","camVX","camVY","flag","push","process","rows","cols","hasFlag","unflag","EXP1","EXP2","forEach","eatDiam","EXIT","nextLevel","apply","gl","assets","x","y","z","w","cellTime","nextSynchro","levelNumber","score","bonus","divDiam","document","getElementById","divScore","eatenDiams","diamSound","pause","currentTime","play","console","log","need","exitX","exitY","exitSound","textContent","max","rockSound","makeDiams","explSound","wait","isLevelDone"],"mappings":"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","sourcesContent":["export default {\n        createEnv\n};\n\nfunction isRockOrDiam( level, col, row ) {\n  var cell = level.getType( col, row );\n  return cell === Level.ROCK || cell === Level.DIAM;\n}\n\nfunction isRockOrDiamOrWall( level, col, row ) {\n  var cell = level.getType( col, row );\n  return cell === Level.ROCK || cell === Level.DIAM || cell === Level.WALL;\n}\n\nfunction prepareMove( col, row, vx, vy, env ) {\n  if( vx === 0 && vy === 0 ) return;\n  var level = env.level;\n  var src = level.getType( col, row );\n  var dst = level.getType( col + vx, row + vy );\n  if( dst === Level.HERO ) env.killHero();\n  else {\n    level.setMove( col, row, vx, vy );\n    level.setType( col + vx, row + vy, -src );\n  }\n};\n\nfunction processFallingRockOrDiam( level, col, row, env, below ) {\n  // La pierre est déjà en train de tomber.\n  // On regarde s'il y a autre chose que du vide dessous. Si c'est\n  // le cas, la chute est stoppée,  mais il peut aussi y avoir des\n  // conséquences sur l'élément qui se trouvait en dessous.\n  if( below !== Level.VOID ) {\n    // On arrête la chute dans tous les cas.\n    level.setVY( col, row, 0 );\n    if( below == Level.ROCK || below == Level.WALL || below == Level.DUST ) {\n      // Le rocher  (ou diamant)  a été  stoppé :  on joue  un son\n      // adéquat.\n      env.playBoom();\n    }\n    else if( below == Level.HERO ) {\n      // On tombe sur le héro : ça le tue.\n      env.killHero();\n    }\n    else if( below == Level.MONS ) {\n      // On écrase un monstre.\n      level.setType( col, row, Level.VOID );\n      env.explode( col, row + 1, true );\n    }\n    else if( below == Level.DIAM ) {\n      // Si c'est une pierre qui tombe sur un diamant, il explose.\n      if( level.getType( col, row ) === Level.ROCK ) {\n        level.setType( col, row, Level.VOID );\n        env.explode( col, row + 1 );\n      }\n    }\n  } else {\n    level.setType( col, row + 1, Level.BOOM );\n  }\n}\n\nfunction processSteadyRockOrDiam( level, col, row, env, below ) {\n  // La pierre est au repos.\n  if( below === Level.VOID ) {\n    level.setMove( col, row, 0, 1 );\n    level.setType( col, row + 1, Level.BOOM );\n  }\n  else if( isRockOrDiamOrWall( level, col, row + 1 ) ) {\n    if( !isRockOrDiam( level, col, row - 1 ) ) {\n      // Si un rocher est posé sur un autre  et qu'il n'est pas sous un rocher/diamant, alors il\n      // peut basculer à droite ou à gauche si l'espace est libre.\n      if( level.getType( col + 1, row ) == Level.VOID\n          && level.getType( col + 1, row + 1 ) == Level.VOID\n          && !isRockOrDiam( level, col + 1, row - 1 ) )\n      {\n        // On tombe sur la droite.\n        level.setMove( col, row, +1, 0 );\n      }\n      else if( level.getType( col - 1, row ) == Level.VOID\n               && level.getType( col - 1, row + 1 ) == Level.VOID\n               && !isRockOrDiam( level, col - 1 , row - 1 ) )\n      {\n        // On tombe sur la gauche seulement s'il n'y a pas déjà un\n        // rocher qui tombe sur la droite juste en face.\n        if( col < 2 || !isRockOrDiam( level, col - 2, row ) || level.getVX( col - 2, row ) < 1 ) {\n          level.setMove( col, row, -1, 0 );\n        }\n      }\n    }\n  }\n}\n\nfunction processRockOrDiam( level, col, row, env ) {\n  level.setVX( col, row, 0 ); // On arrête tout déplacement horizontal.\n\n  var below = level.getType( col, row + 1 );\n  var falling = level.getVY( col, row ) != 0;\n  if( falling ) {\n    processFallingRockOrDiam( level, col, row, env, below );\n  } else {\n    processSteadyRockOrDiam( level, col, row, env, below );\n  }\n}\n\nfunction processExplosion1( env, level, col, row ) {\n  // Une explosion a une durée de vie de 2 cycles.\n  if( level.getIndex( col, row ) > 0 ) {\n    // Encore un cycle...\n    level.setIndex( col, row, level.getIndex( col, row ) - 1 );\n  } else {\n    // C'est terminé pour l'explosion.\n    level.setType( col, row, Level.VOID );\n  }\n}\n\nfunction processExplosion2( env, level, col, row ) {\n  // Une explosion a une durée de vie de 2 cycles.\n  if( level.getIndex( col, row ) > 0 ) {\n    // Encore un cycle...\n    level.setIndex( col, row, level.getIndex( col, row ) - 1 );\n  } else {\n    // C'est terminé pour l'explosion.\n    level.setType( col, row, Level.DIAM );\n    level.setIndex( col, row, Math.floor( Math.random() * 16 ) );\n  }\n}\n\n// Directions du monstre en fonction de attIndex.\n// Il essaie  d'aller dans sa  direction et si c'est  impossible, il\n// essaie sur sa droite et ainsi de suite...\nconst dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];\nfunction processMonster( env, level, col, row ) {\n  var dir = level.getIndex( col, row );\n  var d, k;\n  var vx, vy, v;\n  var target;\n  for( k = 5; k > 1; k-- ) {\n    d = (dir + k) % 4;\n    v = dirs[d];\n    vx = v[0];\n    vy = v[1];\n    target = level.getType( col + vx, row + vy );\n    switch( target ) {\n    case Level.VOID:\n      prepareMove( col, row, vx, vy, env );\n      level.setIndex( col, row, d );\n      return;\n    case Level.HERO:\n      env.killHero();\n      return;\n    case Level.ROCK:\n    case Level.DIAM:\n      if( d == 0 ) {\n        // Si on  monte vers  une pierre,  c'est qu'elle  nous fonce\n        // dessus.\n        env.explode( col, row, true );\n        return;\n      }\n      break;\n    case Level.BOOM:\n      env.explode( col, row, true );\n      return;\n    }\n  }\n  level.setMove( col, row, 0, 0 );\n}\n\nfunction processHero( env, level, col, row, heroMoves, action ) {\n  // Si le héro est mort, on ne fait rien du tout.\n  if( !env.isHeroAlive ) {\n    env.camX = 0;\n    env.camY = 0;\n    return;\n  }\n\n  var move = true;\n\n  var vx = 0;\n  var vy = 0;\n\n  switch( action ) {\n  case GameInputs.UP:\n    vx = 0;\n    vy = -1;\n    break;\n  case GameInputs.RIGHT:\n    vx = 1;\n    vy = 0;\n    level.setIndex( col, row, 0 );\n    break;\n  case GameInputs.DOWN:\n    vx = 0;\n    vy = 1;\n    break;\n  case GameInputs.LEFT:\n    vx = -1;\n    vy = 0;\n    level.setIndex( col, row, 1 );\n    break;\n  case GameInputs.SUICIDE:\n    env.killHero();\n    move = false;\n    break;\n  default:\n    move = false;\n    break;\n  }\n\n  if( move ) {\n    var nextX = col + vx;\n    var nextY = row + vy;\n    var cell = level.getType( nextX, nextY );\n    if( cell === Level.WALL || cell === Level.HERO ) {\n      // Les murs arrêtent le déplacement. Les clones aussi.\n      env.camX = col;\n      env.camY = row;\n      env.camVX = 0;\n      env.camVY = 0;\n      return;\n    }\n\n    if( cell === Level.ROCK ) {\n      // Les rochers aussi, mais ils  peuvent être poussés s'ils ont\n      // un espace vide derrière eux.\n      if( vx === +1 && level.getType( nextX + 1, nextY ) === Level.VOID ) {\n        level.setVX( nextX, nextY, +1 );\n        level.flag( nextX, nextY );\n      }\n      else if( vx === -1 && level.getType( nextX - 1, nextY ) === Level.VOID ) {\n        level.setVX( nextX, nextY, -1 );\n      }\n      // Le héro s'arrête net parce que le rocher est lourd.\n      level.setMove( col, row, 0, 0 );\n      vx = vy = 0;\n    }\n    else {\n      heroMoves.push([ col, row ]);\n      level.flag( nextX, nextY );\n      level.setMove( col, row, vx, vy );\n    }\n  }\n  env.camX = col;\n  env.camY = row;\n  env.camVX = vx;\n  env.camVY = vy;\n}\n\n\n\n  // Déterminer les déplacements futurs.\n function process( env, action ) {\n    // Chaque héro peut manger de la terres (feuilles), mais il faut\n    // la retirer dans  un deuxième temps pour éviter  des effets de\n    // bord sur la chute de pierres vers la gauche.\n    // En effet, si on a une pile de pierre à deux cases à droite du\n    // héro et  que ce dernier  creuse juste à droite,  la prochaine\n    // case analysée sera celle de la pierre et on verra qu'il n'y a\n    // plus rien  à gauche, alors  qu'en réalité, c'est le  héro qui\n    // est censé prendre cette place.\n    // Le résultat  sera que  la pierre  et le  héro auront  la même\n    // cellule comme destination.\n    // `heroMoves` contient les coordonnées du héro.\n    var heroMoves = [];\n\n    var level = env.level;\n    var row, col, cell;\n    for( row = 0; row < level.rows; row++ ) {\n      for( col = 0; col < level.cols; col++ ) {\n        if( level.hasFlag( col, row ) ) {\n          level.unflag( col, row );\n          continue;\n        }\n\n        cell = level.getType( col, row );\n        if( cell === Level.ROCK || cell === Level.DIAM ) {\n          processRockOrDiam( level, col, row, env );\n        }\n        else if( level.getType( col, row ) === Level.HERO ) {\n          processHero( env, level, col, row, heroMoves, action );\n        }\n        else if( cell === Level.MONS ) {\n          processMonster( env, level, col, row );\n        }\n        else if( cell === Level.EXP1 ) {\n          processExplosion1( env, level, col, row );\n        }\n        else if( cell === Level.EXP2 ) {\n          processExplosion2( env, level, col, row );\n        }\n      }\n    }\n    heroMoves.forEach(function (move) {\n      var col = move[0];\n      var row = move[1];\n      var vx = level.getVX( col, row );\n      var vy = level.getVY( col, row );\n      col += vx;\n      row += vy;\n      var cell = level.getType( col, row );\n      if( cell === Level.DUST ) {\n        level.setType( col, row, Level.VOID );\n      }\n      else if( cell === Level.DIAM ) {\n        env.eatDiam();\n        level.setType( col, row, Level.VOID );\n      }\n      else if( cell === Level.EXIT ) env.nextLevel();\n      else if( cell !== Level.VOID ) env.killHero();\n    });\n\n  }\n\n  // Appliquer les déplacements de chaque cellule.\n  function apply( env ) {\n    var level = env.level;\n    var row, col;\n    var isHeroAlive = false;\n    for( row = 0; row < level.rows; row++ ) {\n      for( col = 0; col < level.cols; col++ ) {\n        if( level.getType( col, row ) === Level.HERO ) isHeroAlive = true;\n        if( level.hasFlag( col, row ) ) {\n          // Cellule avec un flag : il ne faut pas la traiter.\n          level.unflag( col, row );\n          continue;\n        }\n        var vx = level.getVX( col, row );\n        var vy = level.getVY( col, row );\n        if( vx != 0 || vy != 0 ) {\n          level.move( col, row, col + vx, row + vy );\n          if( vx > 0 || vy > 0 ) {\n            // On  flag une  cellule  si  elle est  à  droite ou  en\n            // dessous de  la cellule courante.  Cela  évitera de la\n            // prendre  en compte  une  deuxième fois  dans le  même\n            // cycle.\n            level.flag( col + vx, row + vy );\n          }\n        }\n      }\n    }\n    if( !isHeroAlive ) env.killHero();\n  }\n\n  function createEnv(gl, assets) {\n    return {\n      gl: gl,\n      assets: assets,\n      x: 0, y: 0, z: 0, w: 1,\n      cellTime: 180,  // Temps en ms pour traverser une cellule.\n      nextSynchro: -1,\n      levelNumber: 0,\n      score: 0,\n      bonus: 0,\n      divDiam: document.getElementById(\"diam\"),\n      divScore: document.getElementById(\"score\"),\n      //#(eatDiam)\n      eatenDiams: 0,\n      eatDiam: function() {\n        // Les assets finissant par 'ogg', 'mp3' ou 'wav'\n        // sont transpformés en tag AUDIO.\n        assets.diamSound.pause();\n        // Il n'existe pas de méthode `stop()`.\n        // On doit donc faire une pause, puis\n        // remettre le curseur au début de la piste.\n        assets.diamSound.currentTime = 0;\n        assets.diamSound.play();\n        this.eatenDiams++;\n        console.log( this.eatenDiams, \"/\", this.level.need );\n        if( this.eatenDiams == this.level.need ) {\n          this.level.setType( this.level.exitX, this.level.exitY, Level.EXIT );\n          assets.exitSound.play();\n        }\n        this.score += 50;\n        if( this.divDiam ) {\n          this.divDiam.textContent = Math.max(0, this.level.need - this.eatenDiams );\n          this.divScore.textContent = this.score;\n        }\n      },\n      //#(eatDiam)\n      // Bruit du rocher dont la chute est stoppée par un obstacle.\n      playBoom: function() {\n        assets.rockSound.pause();\n        assets.rockSound.currentTime = 0;\n        assets.rockSound.play();\n      },\n      explode: function( col, row, makeDiams ) {\n        var level = this.level;\n        var x, y;\n        this.makeDiams = makeDiams;\n        for( y = row - 1; y < row + 2; y++ ) {\n          for( x = col - 1; x < col + 2; x++ ) {\n            if( level.getType( x, y ) !== Level.WALL && level.getType( x, y ) !== Level.EXIT ) {\n              level.setType( x, y, makeDiams ? Level.EXP2 : Level.EXP1 );\n              level.setIndex( x, y, 1 );\n              level.setMove( x, y, 0, 0 );\n            }\n          }\n        }\n        assets.explSound.pause();\n        assets.explSound.currentTime = 0;\n        assets.explSound.play();\n      },\n      // Vie te mort du Héro.\n      isHeroAlive: true,\n      killHero: function() {\n        if( !this.isHeroAlive ) return;\n\n        this.camVX = this.camVY = 0;\n\n        this.isHeroAlive = false;\n        var col, row;\n        for( row = 0; row < this.level.rows; row++ ) {\n          for( col = 0; col < this.level.cols; col++ ) {\n            if( this.level.getType( col, row ) === Level.HERO ) {\n              this.explode( col, row );\n            }\n          }\n        }\n        this.wait = 4;\n      },\n      isLevelDone: false,\n      nextLevel: function() {\n        this.isLevelDone = true;\n        this.killHero();\n      }\n    };\n  }\n"]},"metadata":{},"sourceType":"module"}
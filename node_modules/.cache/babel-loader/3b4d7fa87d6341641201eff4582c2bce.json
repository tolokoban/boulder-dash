{"ast":null,"code":"import _classCallCheck from \"/home/tolokoban/Code/github/boulder-dash/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/tolokoban/Code/github/boulder-dash/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * BasicHandler(\n *     element: HTMLElement,\n *     handleDown: TBasicHandler,\n *     handleUp: TBasicHandler,\n *     handleMove: TBasicHandler\n * )\n *\n * Deals with three basic events : DOWN, UP and MOVE.\n * If the device has several input pointers, we will return\n * only one event.\n *\n * A TBasicHandler is a synthetic event object:\n *   - x: X coordinate relative to the viewport, not including any scroll offset.\n *   - y: Y coordinate relative to the viewport, not including any scroll offset.\n *   - index: For multi-touch system. The first one is 0, the second is 1, etc.\n *   - buttons: 1 = left, 2 = right.\n *   - pointer: \"mouse\" | \"touch\" | \"pen\".\n *   - clear(): Call stopPropagation() and preventDefault() on this event.\n *\n */\nimport Finger from \"./finger\";\n\nvar BasicHandler =\n/*#__PURE__*/\nfunction () {\n  function BasicHandler(element, handleDown, handleUp, handleMove) {\n    _classCallCheck(this, BasicHandler);\n\n    this.element = void 0;\n    this.pointerType = \"\";\n    this.pointerTypeTime = 0;\n    this.deviceHandlers = {};\n    this.fingers = new Finger();\n    this.element = element;\n    attachDownEvent.call(this, handleDown);\n    attachUpEvent.call(this, handleUp);\n    attachMoveEvent.call(this, handleMove);\n  }\n  /**\n   * If you device can hold mouse and touch events, you will receive two events.\n   * This function prevent it.\n   *\n   * @param   {string} pointerType\n   * @returns {boolean} If `false`, we must ignore this event.\n   */\n\n\n  _createClass(BasicHandler, [{\n    key: \"checkPointerType\",\n    value: function checkPointerType(pointerType) {\n      var now = Date.now();\n      var delay = now - this.pointerTypeTime;\n      this.pointerTypeTime = now;\n\n      if (this.pointerType.length === 0 || delay > 500) {\n        // If the user wat more than 500ms, he can change of pointer.\n        this.pointerType = pointerType;\n        return true;\n      }\n\n      return this.pointerType === pointerType;\n    }\n  }, {\n    key: \"detachEvents\",\n    value: function detachEvents() {\n      var element = this.element;\n      var handlers = this.deviceHandlers;\n      var eventNames = Object.keys(handlers);\n\n      for (var _i = 0, _eventNames = eventNames; _i < _eventNames.length; _i++) {\n        var eventName = _eventNames[_i];\n        var handler = handlers[eventName];\n        element.removeEventListener(eventName, handler, false);\n      }\n    }\n  }]);\n\n  return BasicHandler;\n}();\n\nexport { BasicHandler as default };\n\nfunction attachDownEvent(handleDown) {\n  attachDownEventTouch.call(this, handleDown);\n  attachDownEventMouse.call(this, handleDown);\n}\n\nfunction attachDownEventTouch(handleDown) {\n  var _this = this;\n\n  var element = this.element,\n      deviceHandlers = this.deviceHandlers;\n\n  var handler = function handler(evt) {\n    if (!_this.checkPointerType(\"touch\")) return;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = evt.changedTouches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var touch = _step.value;\n        handleDown({\n          x: touch.clientX,\n          y: touch.clientY,\n          index: _this.fingers.getIndex(touch.identifier),\n          buttons: 1,\n          pointer: \"touch\",\n          clear: createClear(evt)\n        });\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  };\n\n  deviceHandlers.touchstart = handler;\n  element.addEventListener(\"touchstart\", handler, false);\n}\n\nfunction attachDownEventMouse(handleDown) {\n  var _this2 = this;\n\n  var element = this.element,\n      deviceHandlers = this.deviceHandlers;\n\n  var handler = function handler(evt) {\n    if (!_this2.checkPointerType(\"mouse\")) return;\n    handleDown({\n      x: evt.clientX,\n      y: evt.clientY,\n      index: 0,\n      buttons: evt.buttons,\n      pointer: \"mouse\",\n      clear: createClear(evt)\n    });\n  };\n\n  deviceHandlers.mousedown = handler;\n  element.addEventListener(\"mousedown\", handler, false);\n}\n\nfunction attachUpEvent(handleUp) {\n  attachUpEventTouch.call(this, handleUp);\n  attachUpEventMouse.call(this, handleUp);\n}\n\nfunction attachUpEventTouch(handleUp) {\n  var _this3 = this;\n\n  var element = this.element,\n      deviceHandlers = this.deviceHandlers;\n\n  var handler = function handler(evt) {\n    if (!_this3.checkPointerType(\"touch\")) return;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = evt.changedTouches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var touch = _step2.value;\n        handleUp({\n          x: touch.clientX,\n          y: touch.clientY,\n          index: _this3.fingers.getIndex(touch.identifier),\n          buttons: 1,\n          pointer: \"touch\",\n          clear: createClear(evt)\n        });\n\n        _this3.fingers.remove(touch.identifier);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  };\n\n  deviceHandlers.touchend = handler;\n  element.addEventListener(\"touchend\", handler, false);\n}\n\nfunction attachUpEventMouse(handleUp) {\n  var _this4 = this;\n\n  var element = this.element,\n      deviceHandlers = this.deviceHandlers;\n\n  var handler = function handler(evt) {\n    if (!_this4.checkPointerType(\"mouse\")) return;\n    handleUp({\n      x: evt.clientX,\n      y: evt.clientY,\n      index: 0,\n      buttons: evt.buttons,\n      pointer: \"mouse\",\n      clear: createClear(evt)\n    });\n  };\n\n  deviceHandlers.mouseup = handler;\n  element.addEventListener(\"mouseup\", handler, false);\n}\n\nfunction attachMoveEvent(handleMove) {\n  attachMoveEventTouch.call(this, handleMove);\n  attachMoveEventMouse.call(this, handleMove);\n}\n\nfunction attachMoveEventTouch(handleMove) {\n  var _this5 = this;\n\n  var element = this.element,\n      deviceHandlers = this.deviceHandlers;\n\n  var handler = function handler(evt) {\n    if (!_this5.checkPointerType(\"touch\")) return;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = evt.changedTouches[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var touch = _step3.value;\n        handleMove({\n          x: touch.clientX,\n          y: touch.clientY,\n          index: _this5.fingers.getIndex(touch.identifier),\n          buttons: 1,\n          pointer: \"touch\",\n          clear: createClear(evt)\n        });\n\n        _this5.fingers.remove(touch.identifier);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  };\n\n  deviceHandlers.touchmove = handler;\n  element.addEventListener(\"touchmove\", handler, false);\n}\n\nfunction attachMoveEventMouse(handleMove) {\n  var _this6 = this;\n\n  var element = this.element,\n      deviceHandlers = this.deviceHandlers;\n\n  var handler = function handler(evt) {\n    if (!_this6.checkPointerType(\"mouse\")) return;\n    handleMove({\n      x: evt.clientX,\n      y: evt.clientY,\n      index: 0,\n      buttons: evt.buttons,\n      pointer: \"mouse\",\n      clear: createClear(evt)\n    });\n  };\n\n  deviceHandlers.mousemove = handler;\n  element.addEventListener(\"mousemove\", handler, false);\n}\n\nfunction createClear(evt) {\n  return function () {\n    evt.preventDefault();\n    evt.stopPropagation();\n  };\n}","map":{"version":3,"sources":["/home/tolokoban/Code/github/boulder-dash/src/tfw/gesture/basic-handler.ts"],"names":["Finger","BasicHandler","element","handleDown","handleUp","handleMove","pointerType","pointerTypeTime","deviceHandlers","fingers","attachDownEvent","call","attachUpEvent","attachMoveEvent","now","Date","delay","length","handlers","eventNames","Object","keys","eventName","handler","removeEventListener","attachDownEventTouch","attachDownEventMouse","evt","checkPointerType","changedTouches","touch","x","clientX","y","clientY","index","getIndex","identifier","buttons","pointer","clear","createClear","touchstart","addEventListener","mousedown","attachUpEventTouch","attachUpEventMouse","remove","touchend","mouseup","attachMoveEventTouch","attachMoveEventMouse","touchmove","mousemove","preventDefault","stopPropagation"],"mappings":";;;AAAA;;;;;;;;;;;;;;;;;;;;;AAqBA,OAAOA,MAAP,MAAmB,UAAnB;;IAoCqBC,Y;;;AAOjB,wBAAYC,OAAZ,EACIC,UADJ,EAEIC,QAFJ,EAGIC,UAHJ,EAG+B;AAAA;;AAAA,SATtBH,OASsB;AAAA,SAR/BI,WAQ+B,GART,EAQS;AAAA,SAP/BC,eAO+B,GAPL,CAOK;AAAA,SAN/BC,cAM+B,GANG,EAMH;AAAA,SAL/BC,OAK+B,GALb,IAAIT,MAAJ,EAKa;AAC3B,SAAKE,OAAL,GAAeA,OAAf;AACAQ,IAAAA,eAAe,CAACC,IAAhB,CAAqB,IAArB,EAA2BR,UAA3B;AACAS,IAAAA,aAAa,CAACD,IAAd,CAAoB,IAApB,EAA0BP,QAA1B;AACAS,IAAAA,eAAe,CAACF,IAAhB,CAAsB,IAAtB,EAA4BN,UAA5B;AACH;AAED;;;;;;;;;;;qCAOiBC,W,EAAqB;AAClC,UAAMQ,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;AACA,UAAME,KAAK,GAAGF,GAAG,GAAG,KAAKP,eAAzB;AACA,WAAKA,eAAL,GAAuBO,GAAvB;;AACA,UAAI,KAAKR,WAAL,CAAiBW,MAAjB,KAA4B,CAA5B,IAAiCD,KAAK,GAAG,GAA7C,EAAkD;AAC9C;AACA,aAAKV,WAAL,GAAmBA,WAAnB;AACA,eAAO,IAAP;AACH;;AACD,aAAO,KAAKA,WAAL,KAAqBA,WAA5B;AACH;;;mCAEc;AACX,UAAMJ,OAAO,GAAG,KAAKA,OAArB;AACA,UAAMgB,QAAQ,GAAG,KAAKV,cAAtB;AACA,UAAMW,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAYH,QAAZ,CAAnB;;AACA,qCAAwBC,UAAxB,iCAAoC;AAA/B,YAAMG,SAAS,kBAAf;AACD,YAAMC,OAAsC,GAAGL,QAAQ,CAACI,SAAD,CAAvD;AACApB,QAAAA,OAAO,CAACsB,mBAAR,CAA4BF,SAA5B,EAAuCC,OAAvC,EAAgD,KAAhD;AACH;AACJ;;;;;;SA5CgBtB,Y;;AAgDrB,SAASS,eAAT,CAA6CP,UAA7C,EAAwE;AACpEsB,EAAAA,oBAAoB,CAACd,IAArB,CAA0B,IAA1B,EAAgCR,UAAhC;AACAuB,EAAAA,oBAAoB,CAACf,IAArB,CAA0B,IAA1B,EAAgCR,UAAhC;AACH;;AAGD,SAASsB,oBAAT,CAAkDtB,UAAlD,EAA6E;AAAA;;AAAA,MACjED,OADiE,GACrC,IADqC,CACjEA,OADiE;AAAA,MACxDM,cADwD,GACrC,IADqC,CACxDA,cADwD;;AAEzE,MAAMe,OAAO,GAAG,SAAVA,OAAU,CAACI,GAAD,EAAsB;AAClC,QAAI,CAAC,KAAI,CAACC,gBAAL,CAAsB,OAAtB,CAAL,EAAqC;AADH;AAAA;AAAA;;AAAA;AAElC,2BAAoBD,GAAG,CAACE,cAAxB,8HAAwC;AAAA,YAA7BC,KAA6B;AACpC3B,QAAAA,UAAU,CAAC;AACP4B,UAAAA,CAAC,EAAED,KAAK,CAACE,OADF;AAEPC,UAAAA,CAAC,EAAEH,KAAK,CAACI,OAFF;AAGPC,UAAAA,KAAK,EAAE,KAAI,CAAC1B,OAAL,CAAa2B,QAAb,CAAsBN,KAAK,CAACO,UAA5B,CAHA;AAIPC,UAAAA,OAAO,EAAE,CAJF;AAKPC,UAAAA,OAAO,EAAE,OALF;AAMPC,UAAAA,KAAK,EAAEC,WAAW,CAACd,GAAD;AANX,SAAD,CAAV;AAQH;AAXiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYrC,GAZD;;AAaAnB,EAAAA,cAAc,CAACkC,UAAf,GAA4BnB,OAA5B;AACArB,EAAAA,OAAO,CAACyC,gBAAR,CAAyB,YAAzB,EAAuCpB,OAAvC,EAAgD,KAAhD;AACH;;AAGD,SAASG,oBAAT,CAAkDvB,UAAlD,EAA6E;AAAA;;AAAA,MACjED,OADiE,GACrC,IADqC,CACjEA,OADiE;AAAA,MACxDM,cADwD,GACrC,IADqC,CACxDA,cADwD;;AAEzE,MAAMe,OAAO,GAAG,SAAVA,OAAU,CAACI,GAAD,EAAsB;AAClC,QAAI,CAAC,MAAI,CAACC,gBAAL,CAAsB,OAAtB,CAAL,EAAqC;AACrCzB,IAAAA,UAAU,CAAC;AACP4B,MAAAA,CAAC,EAAEJ,GAAG,CAACK,OADA;AAEPC,MAAAA,CAAC,EAAEN,GAAG,CAACO,OAFA;AAGPC,MAAAA,KAAK,EAAE,CAHA;AAIPG,MAAAA,OAAO,EAAEX,GAAG,CAACW,OAJN;AAKPC,MAAAA,OAAO,EAAE,OALF;AAMPC,MAAAA,KAAK,EAAEC,WAAW,CAACd,GAAD;AANX,KAAD,CAAV;AAQH,GAVD;;AAWAnB,EAAAA,cAAc,CAACoC,SAAf,GAA2BrB,OAA3B;AACArB,EAAAA,OAAO,CAACyC,gBAAR,CAAyB,WAAzB,EAAsCpB,OAAtC,EAA+C,KAA/C;AACH;;AAGD,SAASX,aAAT,CAA2CR,QAA3C,EAAoE;AAChEyC,EAAAA,kBAAkB,CAAClC,IAAnB,CAAwB,IAAxB,EAA8BP,QAA9B;AACA0C,EAAAA,kBAAkB,CAACnC,IAAnB,CAAwB,IAAxB,EAA8BP,QAA9B;AACH;;AAGD,SAASyC,kBAAT,CAAgDzC,QAAhD,EAAyE;AAAA;;AAAA,MAC7DF,OAD6D,GACjC,IADiC,CAC7DA,OAD6D;AAAA,MACpDM,cADoD,GACjC,IADiC,CACpDA,cADoD;;AAErE,MAAMe,OAAO,GAAG,SAAVA,OAAU,CAACI,GAAD,EAAsB;AAClC,QAAI,CAAC,MAAI,CAACC,gBAAL,CAAsB,OAAtB,CAAL,EAAqC;AADH;AAAA;AAAA;;AAAA;AAElC,4BAAoBD,GAAG,CAACE,cAAxB,mIAAwC;AAAA,YAA7BC,KAA6B;AACpC1B,QAAAA,QAAQ,CAAC;AACL2B,UAAAA,CAAC,EAAED,KAAK,CAACE,OADJ;AAELC,UAAAA,CAAC,EAAEH,KAAK,CAACI,OAFJ;AAGLC,UAAAA,KAAK,EAAE,MAAI,CAAC1B,OAAL,CAAa2B,QAAb,CAAsBN,KAAK,CAACO,UAA5B,CAHF;AAILC,UAAAA,OAAO,EAAE,CAJJ;AAKLC,UAAAA,OAAO,EAAE,OALJ;AAMLC,UAAAA,KAAK,EAAEC,WAAW,CAACd,GAAD;AANb,SAAD,CAAR;;AAQA,QAAA,MAAI,CAAClB,OAAL,CAAasC,MAAb,CAAoBjB,KAAK,CAACO,UAA1B;AACH;AAZiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAarC,GAbD;;AAcA7B,EAAAA,cAAc,CAACwC,QAAf,GAA0BzB,OAA1B;AACArB,EAAAA,OAAO,CAACyC,gBAAR,CAAyB,UAAzB,EAAqCpB,OAArC,EAA8C,KAA9C;AACH;;AAGD,SAASuB,kBAAT,CAAgD1C,QAAhD,EAAyE;AAAA;;AAAA,MAC7DF,OAD6D,GACjC,IADiC,CAC7DA,OAD6D;AAAA,MACpDM,cADoD,GACjC,IADiC,CACpDA,cADoD;;AAErE,MAAMe,OAAO,GAAG,SAAVA,OAAU,CAACI,GAAD,EAAsB;AAClC,QAAI,CAAC,MAAI,CAACC,gBAAL,CAAsB,OAAtB,CAAL,EAAqC;AACrCxB,IAAAA,QAAQ,CAAC;AACL2B,MAAAA,CAAC,EAAEJ,GAAG,CAACK,OADF;AAELC,MAAAA,CAAC,EAAEN,GAAG,CAACO,OAFF;AAGLC,MAAAA,KAAK,EAAE,CAHF;AAILG,MAAAA,OAAO,EAAEX,GAAG,CAACW,OAJR;AAKLC,MAAAA,OAAO,EAAE,OALJ;AAMLC,MAAAA,KAAK,EAAEC,WAAW,CAACd,GAAD;AANb,KAAD,CAAR;AAQH,GAVD;;AAWAnB,EAAAA,cAAc,CAACyC,OAAf,GAAyB1B,OAAzB;AACArB,EAAAA,OAAO,CAACyC,gBAAR,CAAyB,SAAzB,EAAoCpB,OAApC,EAA6C,KAA7C;AACH;;AAKD,SAASV,eAAT,CAA6CR,UAA7C,EAAwE;AACpE6C,EAAAA,oBAAoB,CAACvC,IAArB,CAA0B,IAA1B,EAAgCN,UAAhC;AACA8C,EAAAA,oBAAoB,CAACxC,IAArB,CAA0B,IAA1B,EAAgCN,UAAhC;AACH;;AAGD,SAAS6C,oBAAT,CAAkD7C,UAAlD,EAA6E;AAAA;;AAAA,MACjEH,OADiE,GACrC,IADqC,CACjEA,OADiE;AAAA,MACxDM,cADwD,GACrC,IADqC,CACxDA,cADwD;;AAEzE,MAAMe,OAAO,GAAG,SAAVA,OAAU,CAACI,GAAD,EAAsB;AAClC,QAAI,CAAC,MAAI,CAACC,gBAAL,CAAsB,OAAtB,CAAL,EAAqC;AADH;AAAA;AAAA;;AAAA;AAElC,4BAAoBD,GAAG,CAACE,cAAxB,mIAAwC;AAAA,YAA7BC,KAA6B;AACpCzB,QAAAA,UAAU,CAAC;AACP0B,UAAAA,CAAC,EAAED,KAAK,CAACE,OADF;AAEPC,UAAAA,CAAC,EAAEH,KAAK,CAACI,OAFF;AAGPC,UAAAA,KAAK,EAAE,MAAI,CAAC1B,OAAL,CAAa2B,QAAb,CAAsBN,KAAK,CAACO,UAA5B,CAHA;AAIPC,UAAAA,OAAO,EAAE,CAJF;AAKPC,UAAAA,OAAO,EAAE,OALF;AAMPC,UAAAA,KAAK,EAAEC,WAAW,CAACd,GAAD;AANX,SAAD,CAAV;;AAQA,QAAA,MAAI,CAAClB,OAAL,CAAasC,MAAb,CAAoBjB,KAAK,CAACO,UAA1B;AACH;AAZiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAarC,GAbD;;AAcA7B,EAAAA,cAAc,CAAC4C,SAAf,GAA2B7B,OAA3B;AACArB,EAAAA,OAAO,CAACyC,gBAAR,CAAyB,WAAzB,EAAsCpB,OAAtC,EAA+C,KAA/C;AACH;;AAGD,SAAS4B,oBAAT,CAAkD9C,UAAlD,EAA6E;AAAA;;AAAA,MACjEH,OADiE,GACrC,IADqC,CACjEA,OADiE;AAAA,MACxDM,cADwD,GACrC,IADqC,CACxDA,cADwD;;AAEzE,MAAMe,OAAO,GAAG,SAAVA,OAAU,CAACI,GAAD,EAAsB;AAClC,QAAI,CAAC,MAAI,CAACC,gBAAL,CAAsB,OAAtB,CAAL,EAAqC;AACrCvB,IAAAA,UAAU,CAAC;AACP0B,MAAAA,CAAC,EAAEJ,GAAG,CAACK,OADA;AAEPC,MAAAA,CAAC,EAAEN,GAAG,CAACO,OAFA;AAGPC,MAAAA,KAAK,EAAE,CAHA;AAIPG,MAAAA,OAAO,EAAEX,GAAG,CAACW,OAJN;AAKPC,MAAAA,OAAO,EAAE,OALF;AAMPC,MAAAA,KAAK,EAAEC,WAAW,CAACd,GAAD;AANX,KAAD,CAAV;AAQH,GAVD;;AAWAnB,EAAAA,cAAc,CAAC6C,SAAf,GAA2B9B,OAA3B;AACArB,EAAAA,OAAO,CAACyC,gBAAR,CAAyB,WAAzB,EAAsCpB,OAAtC,EAA+C,KAA/C;AACH;;AAGD,SAASkB,WAAT,CAAqBd,GAArB,EAA0B;AACtB,SAAO,YAAM;AACTA,IAAAA,GAAG,CAAC2B,cAAJ;AACA3B,IAAAA,GAAG,CAAC4B,eAAJ;AACH,GAHD;AAIH","sourcesContent":["/**\n * BasicHandler(\n *     element: HTMLElement,\n *     handleDown: TBasicHandler,\n *     handleUp: TBasicHandler,\n *     handleMove: TBasicHandler\n * )\n *\n * Deals with three basic events : DOWN, UP and MOVE.\n * If the device has several input pointers, we will return\n * only one event.\n *\n * A TBasicHandler is a synthetic event object:\n *   - x: X coordinate relative to the viewport, not including any scroll offset.\n *   - y: Y coordinate relative to the viewport, not including any scroll offset.\n *   - index: For multi-touch system. The first one is 0, the second is 1, etc.\n *   - buttons: 1 = left, 2 = right.\n *   - pointer: \"mouse\" | \"touch\" | \"pen\".\n *   - clear(): Call stopPropagation() and preventDefault() on this event.\n *\n */\nimport Finger from \"./finger\"\nimport {IBasicEvent} from \"./basic-handler.types\"\n\ninterface ITouch {\n    identifier: number;\n    clientX: number;\n    clientY: number;\n}\n\ninterface ITouchEvent {\n    changedTouches: ITouch[];\n}\ntype TTouchEventHandler = (evt:ITouchEvent) => void;\n\ninterface IMouseEvent {\n    clientX: number;\n    clientY: number;\n    buttons: number;\n}\ntype TMouseEventHandler = (evt:IMouseEvent) => void;\n\ntype TDeviceEventHandler = TTouchEventHandler|TMouseEventHandler;\n\ntype TBasicHandler = (evt: IBasicEvent) => void | undefined;\n\ntype TBasicEventName = \"mousedown\";\n\ninterface IDeviceHandlers {\n    touchstart?: TTouchEventHandler;\n    touchend?: TTouchEventHandler;\n    touchmove?: TTouchEventHandler;\n    mousedown?: TMouseEventHandler;\n    mouseup?: TMouseEventHandler;\n    mousemove?: TMouseEventHandler;\n}\n\nexport default class BasicHandler {\n    readonly element: HTMLElement;\n    pointerType: string = \"\";\n    pointerTypeTime: number = 0;\n    deviceHandlers: IDeviceHandlers = {};\n    fingers: Finger = new Finger();\n\n    constructor(element: HTMLElement,\n        handleDown: TBasicHandler,\n        handleUp: TBasicHandler,\n        handleMove: TBasicHandler) {\n        this.element = element;\n        attachDownEvent.call(this, handleDown);\n        attachUpEvent.call( this, handleUp );\n        attachMoveEvent.call( this, handleMove );\n    }\n\n    /**\n     * If you device can hold mouse and touch events, you will receive two events.\n     * This function prevent it.\n     *\n     * @param   {string} pointerType\n     * @returns {boolean} If `false`, we must ignore this event.\n     */\n    checkPointerType(pointerType: string) {\n        const now = Date.now();\n        const delay = now - this.pointerTypeTime;\n        this.pointerTypeTime = now;\n        if (this.pointerType.length === 0 || delay > 500) {\n            // If the user wat more than 500ms, he can change of pointer.\n            this.pointerType = pointerType;\n            return true;\n        }\n        return this.pointerType === pointerType;\n    }\n\n    detachEvents() {\n        const element = this.element;\n        const handlers = this.deviceHandlers;\n        const eventNames = Object.keys(handlers);\n        for (const eventName of eventNames) {\n            const handler: TDeviceEventHandler|undefined = handlers[eventName as TBasicEventName];\n            element.removeEventListener(eventName, handler, false);\n        }\n    }\n}\n\n\nfunction attachDownEvent(this: BasicHandler, handleDown: TBasicHandler) {\n    attachDownEventTouch.call(this, handleDown);\n    attachDownEventMouse.call(this, handleDown);\n}\n\n\nfunction attachDownEventTouch(this: BasicHandler, handleDown: TBasicHandler) {\n    const { element, deviceHandlers } = this;\n    const handler = (evt: ITouchEvent) => {\n        if (!this.checkPointerType(\"touch\")) return;\n        for (const touch of evt.changedTouches) {\n            handleDown({\n                x: touch.clientX,\n                y: touch.clientY,\n                index: this.fingers.getIndex(touch.identifier),\n                buttons: 1,\n                pointer: \"touch\",\n                clear: createClear(evt)\n            });\n        }\n    };\n    deviceHandlers.touchstart = handler;\n    element.addEventListener(\"touchstart\", handler, false);\n}\n\n\nfunction attachDownEventMouse(this: BasicHandler, handleDown: TBasicHandler) {\n    const { element, deviceHandlers } = this;\n    const handler = (evt: IMouseEvent) => {\n        if (!this.checkPointerType(\"mouse\")) return;\n        handleDown({\n            x: evt.clientX,\n            y: evt.clientY,\n            index: 0,\n            buttons: evt.buttons,\n            pointer: \"mouse\",\n            clear: createClear(evt)\n        });\n    };\n    deviceHandlers.mousedown = handler;\n    element.addEventListener(\"mousedown\", handler, false);\n}\n\n\nfunction attachUpEvent(this: BasicHandler, handleUp: TBasicHandler) {\n    attachUpEventTouch.call(this, handleUp);\n    attachUpEventMouse.call(this, handleUp);\n}\n\n\nfunction attachUpEventTouch(this: BasicHandler, handleUp: TBasicHandler) {\n    const { element, deviceHandlers } = this;\n    const handler = (evt: ITouchEvent) => {\n        if (!this.checkPointerType(\"touch\")) return;\n        for (const touch of evt.changedTouches) {\n            handleUp({\n                x: touch.clientX,\n                y: touch.clientY,\n                index: this.fingers.getIndex(touch.identifier),\n                buttons: 1,\n                pointer: \"touch\",\n                clear: createClear(evt)\n            });\n            this.fingers.remove(touch.identifier)\n        }\n    };\n    deviceHandlers.touchend = handler;\n    element.addEventListener(\"touchend\", handler, false);\n}\n\n\nfunction attachUpEventMouse(this: BasicHandler, handleUp: TBasicHandler) {\n    const { element, deviceHandlers } = this;\n    const handler = (evt: IMouseEvent) => {\n        if (!this.checkPointerType(\"mouse\")) return;\n        handleUp({\n            x: evt.clientX,\n            y: evt.clientY,\n            index: 0,\n            buttons: evt.buttons,\n            pointer: \"mouse\",\n            clear: createClear(evt)\n        });\n    };\n    deviceHandlers.mouseup = handler;\n    element.addEventListener(\"mouseup\", handler, false);\n}\n\n\n\n\nfunction attachMoveEvent(this: BasicHandler, handleMove: TBasicHandler) {\n    attachMoveEventTouch.call(this, handleMove);\n    attachMoveEventMouse.call(this, handleMove);\n}\n\n\nfunction attachMoveEventTouch(this: BasicHandler, handleMove: TBasicHandler) {\n    const { element, deviceHandlers } = this;\n    const handler = (evt: ITouchEvent) => {\n        if (!this.checkPointerType(\"touch\")) return;\n        for (const touch of evt.changedTouches) {\n            handleMove({\n                x: touch.clientX,\n                y: touch.clientY,\n                index: this.fingers.getIndex(touch.identifier),\n                buttons: 1,\n                pointer: \"touch\",\n                clear: createClear(evt)\n            });\n            this.fingers.remove(touch.identifier)\n        }\n    };\n    deviceHandlers.touchmove = handler;\n    element.addEventListener(\"touchmove\", handler, false);\n}\n\n\nfunction attachMoveEventMouse(this: BasicHandler, handleMove: TBasicHandler) {\n    const { element, deviceHandlers } = this;\n    const handler = (evt: IMouseEvent) => {\n        if (!this.checkPointerType(\"mouse\")) return;\n        handleMove({\n            x: evt.clientX,\n            y: evt.clientY,\n            index: 0,\n            buttons: evt.buttons,\n            pointer: \"mouse\",\n            clear: createClear(evt)\n        });\n    };\n    deviceHandlers.mousemove = handler;\n    element.addEventListener(\"mousemove\", handler, false);\n}\n\n\nfunction createClear(evt) {\n    return () => {\n        evt.preventDefault();\n        evt.stopPropagation();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}